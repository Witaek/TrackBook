<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content=" The Trackbook describes the structures and goals of the RusTracker project">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded "><a href="prerequis.html"><strong aria-hidden="true">1.</strong> Prérequis</a></li><li class="chapter-item expanded "><a href="architecture.html"><strong aria-hidden="true">2.</strong> Architecture</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Guide d'utilisation</li><li class="chapter-item expanded affix "><li class="part-title">Contexte</li><li class="chapter-item expanded "><a href="contexte.html"><strong aria-hidden="true">3.</strong> Set up</a></li><li class="chapter-item expanded affix "><li class="part-title">Source</li><li class="chapter-item expanded "><a href="source/reception.html"><strong aria-hidden="true">4.</strong> Source</a></li><li class="chapter-item expanded "><a href="source/setup.html"><strong aria-hidden="true">5.</strong> Set up</a></li><li class="chapter-item expanded affix "><li class="part-title">Rustracker</li><li class="chapter-item expanded "><a href="rustracker/index.html"><strong aria-hidden="true">6.</strong> Rustracker</a></li><li class="chapter-item expanded "><a href="rustracker/position.html"><strong aria-hidden="true">7.</strong> Position</a></li><li class="chapter-item expanded "><a href="rustracker/vitesse.html"><strong aria-hidden="true">8.</strong> Vitesse</a></li><li class="chapter-item expanded "><a href="rustracker/callsign.html"><strong aria-hidden="true">9.</strong> callsign</a></li><li class="chapter-item expanded affix "><li class="part-title">Trackui</li><li class="chapter-item expanded "><a href="trackui/index.html"><strong aria-hidden="true">10.</strong> Trackui</a></li><li class="chapter-item expanded "><a href="trackui/vm.html"><strong aria-hidden="true">11.</strong> Machine Virtuelle</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Test Results</li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="story.html">Project Storyline</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="conclusion.html">Conclusion</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p style="text-align:justify;">L’ADS-B (Automatic Dependent Surveillance-Broadcast) est un système de contrôle du
trafic aérien. Un avion utilisant l’ADS-B détermine sa position par un système de positionnement satellite et
la renvoit cette dernière (ainsi que d’autres informations sur le vol, altitude, vitesse, modèle de l’avion, etc)
dans toutes les directions aux autres appareils disposant de l’ADS-B. Ces messages sont détectables, puis
démodulables, par toute personne à l’aide d’une clef TNT (tuner RTL2832U, 15€), utilisée en SDR (Software Defined Radio),
qui permet de définir les paramètres de réception, comme par exemple la fréquence,
depuis l’ordinateur. L’objectif du projet est d’utiliser ces messages envoyés par les avions, et de proposer
une interface graphique à l’utilisateur. Sur cette interface, on souhaite observer en temps réel l’ensemble
des avions à portée de notre antenne ; nous souhaitons également pouvoir observer la trajectoire des avions
ainsi que connaître les informations sur le vol (altitude, vitesse, moteur, ...).</p>
<h3 id="description-du-livrable-minimal-"><a class="header" href="#description-du-livrable-minimal-">Description du livrable minimal :</a></h3>
<ul>
<li>Intercepter, démoduler, interpréter des signaux ADS-B envoyés par plusieurs avions</li>
<li>En extraire des informations sur la position, vitesse, modèle,...</li>
<li>Utiliser ces données pour générer en temps réel une carte sur laquelle figurent les avions</li>
<li>Possibilité d’obtenir les informations concernant le vol des avions sélectionnés</li>
</ul>
<br/>
<p style="text-align: center;">
<img  typeof="foaf:Image" src="images/exemple.png"  width="350" height="350" alt="" title="Foto: Edis Škulj/fkmladost.ba">  
</p>
<p style="text-align: center;">
    <b> Exemple de carte recherchée (FlightRadar24) </b>
</p>
<h3 id="description-brève-"><a class="header" href="#description-brève-">Description brève :</a></h3>
<p>Ce projet est décomposée en trois parties communicantes les unes avec les autres : Source, Rustracker et TrackUI.</p>
<p style="text-align:justify;">
<ul>
  <li> <p style="text-align:justify;"> <b>Source</b> : c'est le programme chargé d'intercepter les signaux ADS-B émis par les avions à 1090MHz. Il procède ensuite de les démoduler (réception sous forme de I&Qs), de les convertir en binaire et les envoit, grâce au protocole TCP, à Rustracker. </p></li>
  <li> <p style="text-align:justify;"> <b>Rustracker</b>: c'est le programme principal, stocké sur une machine virtuelle, qui récupère les signaux sous forme binaire émis par Source, les interprète afin d'en extraire les informations sur le vol des avions (position, vitesse, altitude, numéro de vol, etc). Il écrit toutes ces informations dans un fichier geojson qui sera lu par Trackui. </p> </li>
  <li><p style="text-align:justify;"> <b>Trackui</b>: il s'agit de l'interface graphique de notre travail, sous forme de page web, herbergée par un serveur nginx sur la machine virtuelle évoquée plus tôt. Elle consulte à intervalles de temps régulier le fichier geojson mis à disposition par Rustracker et affiche les avions en conséquences sur la carte, les autres données concernant les avions sont regroupées dans un tableau à côté de la carte.</p>
</li>
</ul> 
</p><div style="break-before: page; page-break-before: always;"></div><h1 id="prérequis"><a class="header" href="#prérequis">Prérequis</a></h1>
<h2 id="rust"><a class="header" href="#rust">Rust</a></h2>
<p>Afin de faire tourner nos différents programmes (Source &amp; Rustracker), il est nécessaire d'installer le gestionnaire de paquet rust &quot;Cargo&quot; ainsi que le gestionnaire des chaînes d'outils &quot;rustup&quot;.</p>
<pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<br/>
<hr />
<h2 id="source"><a class="header" href="#source">Source</a></h2>
<p style="text-align:justify;">Afin de faire fonctionner Source,  il est nécessaire de correctement configurer les drivers pour utiliser les antennes RTL-SDR correctement. On propose ici un guide afin d'effectuer correctement les installations nécessaires au bon fonctionnement de Source.</p>
<h4 id="blacklist-des-pilotes"><a class="header" href="#blacklist-des-pilotes">Blacklist des pilotes</a></h4>
<p>Commençons par connecter le dongle TNT à l'ordinateur.</p>
<p>--&gt; La commande <code>dsemg</code> permet de vérifier que le dongle est bien connecté.</p>
<p>Nous allons maintenant blacklister le pilote permettant de regarder la TNT avec le dongle afin qu'il n'interfère pas dans le bon fonctionnement de notre programme.</p>
<pre><code>~ $ cd /etc/modprobe.d
/etc/modprobe.d $ sudo nano rtlsdr.conf
</code></pre>
<p>Rajoutons la ligne suivante dans le fichier rtlsdr.conf :</p>
<blockquote>
<p>blacklist dvb_usb_rtl28xxu</p>
</blockquote>
<p>Sauvegardons ensuite rtlsdr.conf.</p>
<p>--&gt; La commande <code>lsmod</code> permet de vérifier si le pilote est chargé</p>
<p>Enfin, supprimons le pilote déjà chargé.</p>
<pre><code>~ $ blacklist dvb_usb_rtl28xxu
</code></pre>
<h4 id="installation-des-pilotes"><a class="header" href="#installation-des-pilotes">Installation des pilotes</a></h4>
<p>Commençons par installer la librairie nécessaire à l'utilisation de SoapySDR, la crate que nous utilisons afin d'utiliser les dongles rtlsdr avec notre code RUST.</p>
<pre><code>sudo apt install libsoapysdr-dev libclang-dev llvm-dev pkg-config
</code></pre>
<p>On installe ensuite le pilote correspondant.</p>
<pre><code>sudo apt install soapysdr-module-rtlsdr
</code></pre>
<p>Enfin on installe le plugin Soapy pour RTL-SDR.</p>
<pre><code>git clone https://github.com/pothosware/SoapyRTLSDR.git
cd SoapyRTLSDR
mkdir build
cd build
cmake ..
make
sudo make install
</code></pre>
<br/>
<hr />
<h2 id="rustracker"><a class="header" href="#rustracker">Rustracker</a></h2>
<p>L'installation de certaines librairies est nécessaires au bon fonctionnement du programme Rustracker.</p>
<p>Installons d'abord une librairie permettant d'utiliser pkg-config, un programme de gestion des librairies.</p>
<pre><code>sudo apt install pkg-config
</code></pre>
<p>On installe ensuite la librairie ZeroMQ que l'on utiliser pour les communications tcp entre Source et Rustracker.</p>
<pre><code>sudo apt install libzmq3-dev
</code></pre>
<p>Enfin, on installe deux packages nécessaires à la compilation.</p>
<pre><code>sudo apt install build-essential
sudo apt install cmake</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="format"><a class="header" href="#format">Format</a></h1>
<p>Notre projet s'est divisé en trois grande partie :</p>
<ol>
<li>La réception des messages : Source</li>
<li>Leur traitement : Rustracker</li>
<li>Leur affichage dans une interface graphique : Trackui</li>
</ol>
<p style="text-align:justify;"> 
L'intéraction entre ces trois parties est présentée dans le diagramme suivant qui facilitera la compréhension de l'architecture du projet que nous allons vous présenter. </p>
<p><img src="images/rustracker.png" alt="Diagramme rustracker" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contexte"><a class="header" href="#contexte">Contexte</a></h1>
<p style="text-align:justify;">
Le résultat finale présente sous forme de carte interactive des avions, toutefois, l’information a suivit un long processus avant de pouvoir être présentée sous une forme compréhensible pour l’utilisateur.</p>
<p>Nous allons donc nous intéresser au voyage d’un message ADS-B.</p>
<p style="text-align:justify;"> 
Comme nous l’avons spécifié en introduction, l’*Automatic Dependent Surveillance-Broadcast* (ADS-B) est un mode de communication qui sert au contrôle aérien.
</p>
Les deux premières lettres de l’acronyme permettent de comprendre les enjeux du formatage et du mode de transmission des messages.
<p style="text-align:justify;"> 
*« Automatic »* signifie que les messages sont envoyés automatiquement, il n’est pas nécessaire de solliciter le transpondeur de l’avion pour obtenir une réponse (ce qui se fait dans d’autre méthode de contrôle aérien). Cela impose donc aussi d’avoir un programme suffisamment performant pour soutenir les flows de messages.
</p>
<p style="text-align:justify;"> 
*« Dependent »* caractérise la provenance de ces informations. Tout est transmis par l’avion lui-même. Par exemple pour sa position, il la défini à partir de son système GPS embarqué avant de la transmettre. L’implication directe concerne le formatage des messages : il faut, dans un nombre de bits limités, transmettre suffisamment d’informations pour lier le message à l’avion et donner des informations suffisamment précises, et diverses (positions, vitesse, numéro de vol, …)
</p>
<h1 id="format-1"><a class="header" href="#format-1">Format</a></h1>
<p>Ainsi, le format d’un message ADS-B se présente sous la forme suivante :</p>
<p>Il comporte 112 bits, divisés en parties distinctes, chacune portant des informations spécifiques :</p>
<p style="text-align:justify;">
<ul>
  <li> <p style="text-align:justify;"> 
<p><b>[0 ; 4] : Downlink format :</b>  C’est le format de transmission, on ne s’intéresse ici qu’au 17, qui est le plus largement utilisé dans l’aviation civile. </p></li></p>
<li> <p style="text-align:justify;"> 
  <b>[5 ; 7] : Capability : </b> C’est un champ à utilisation technique que l’on traite techniquement dans le programme mais dont l’utilité pour un utilisateur lambda est faible, le résultat n’est donc pas présenté dans l’interface graphique (il permet d’obtenir notamment l’importance des tourbillons marginaux créés par l’avion, qui sont un phénomène dangereux pour un autre avion situé derrière, et est donc utilisé par les contrôleurs pour assurer une bonne séparation.</p> </li>
  <li><p style="text-align:justify;"> 
  <b>[8 ; 31] : adresse ICAO :</b>C’est l’élément le plus important du message, il s’agit d’un code hexadécimal et unique à l’avion tout au long de sa « vie ». Ce code étant unique et se trouvant dans tous les messages, c’est lui qui va permettre de lier des messages reçus indépendamment à l’avion émetteur.
</p>
</li>
 <li><p style="text-align:justify;"> 
 <b>[32 ; 87] : data : </b> Ces 56 bits sont le cœur du message, c’est eux qui transportent l’information spécifique au vol à l’instant t. Les 5 premiers correspondent au « Type Code », qui nous indique le type de data reçu. Il peut s’agir de la vitesse, de la position, ou du numéro de vol, dont les formatages peuvent varier (nous le détaillerons plus tard).</p>
</li>
 <li><p style="text-align:justify;"> 
 <b>[88 ; 111] : CRC :</b>Ces derniers bits correspondent au contrôle de redondance cyclique (CRC). Ils sont calculés à l’émission de façon à ce qu’une opération logique sur l’ensemble des 112 bits donne un résultat spécifique, permettant ainsi de valider l’intégrité du message reçu. En effet, on reçoit de nombreux messages mais entre l’avion et notre antenne de réception, ils ont pu être dégradés d’une telle façon que l’information transportée est erronée. </p>
</li>
</ul> 
</p>
<p style="text-align:justify;"> 
Maintenant que l’on connait ce qu’est un message ADS-B, nous allons pouvoir étudier tout son cheminement. Nous utiliserons par la suite le terme anglais de Squitter pour désigner un tel message.
</p><div style="break-before: page; page-break-before: always;"></div><h1 id="source-1"><a class="header" href="#source-1">Source</a></h1>
<p style="text-align:justify;">La réception des squitter se fait de façon indépendante de leur traitement dans un programme Rust nommé « Source ».
<p>Le principe est d’installer ce programme sur une station (dans notre cas un raspberry pi) dont le but est de capter le signal et de le transmettre au serveur.</p>
<p style="text-align:justify;">
Le squitter est d’abords émis par l’avion omnidirectionnellement sur la fréquence de 1090MH, il voyage alors à travers l’atmosphère avant d’être réceptionné par notre antenne. L’onde de 1090Mhz est alors échantillonnée à l’aide un Dongle DVB-T pourvu d’une puce <b>RTL2832U</b>. Originellement destiné à être utilisé pour la réception de la TNT (≈20€), l’utilisations de drivers différents permet de le convertir en système SDR (Software Define Radio), dont on peut choisir la fréquence de réception.</p>
<p style="text-align:justify;">
Nous avons fait le choix d’utiliser Soapy SDR (disponible en package pour Rust), qui permet à l’aide de simple ligne de code de se connecter au dongle et de choisir le taux d’échantillonnage, la fréquence de réception et le gain. </p>
<p style="text-align:justify;">
L’onde est modulée en quadrature (I&Q), le résultat est donc sous forme de complexe, que l’on démodule en prenant le module. A partir de là, on dispose de l’onde, toutefois il faut encore identifier les messages ads-b situés dans l’échantillon. Ils sont échantillonnés à une fréquence : </p>
<p style="text-align: center;">
<code>
 fe = 2.10<sup>6</sup> Hz (soit Te = 500 ns)
 </code> </p>
 <p style="text-align:justify;">Sachant qu’il faut deux amplitudes pour coder un bit, la durée totale d’un message est de 112 microsecondes. Pour identifier le début du squitter on s’appuie sur la détection du préambule. Il s’agit d’un motif caractéristique (cf. image). Il existe plusieurs moyens de détecter un préambule (cf. bibliographie), nous avons utiliser la détection logique du préambule. Le but de cette méthode est d’identifier par des opérations logiques (<, >) les successions d’amplitudes sur l’onde s’apparentant au motif (cf. figure préambule)</p>
<p style="text-align: center;">
<img  typeof="foaf:Image" src="source/../images/preambule.jpg"  alt="" title="preambule">  
</p>
<p style="text-align:justify;">
Pour ce faire, on parcourt l’échantillon de l’onde, puis à partir de l’amplitude [i], on établie une moyenne des valeurs « haute » ([i], [i+2], [i+7], [i+9]), puis on vérifie que toutes les autres valeurs jusqu’à [i+15] sont inférieures aux valeurs hautes et vérifient les bonnes variations d’amplitudes. </p>
<p style="text-align:justify;">
Dès que l’on identifie un préambule, on stocke les 224 points suivants de l’échantillon pour les convertir en binaire selon la méthode suivante :
Chaque paire de points successives et d’amplitudes (A1, A2) définit un unique bit b tel que si A1>A2 alors b = 1, sinon b=0.</p>
<p>Nous obtenons enfin les 112 bits.</p>
<p>Dès lors, nous sommes en mesure de vérifier l’intégrité du message à l’aide du CRC.</p>
<p>Ce dernier se représente sous la forme d’un polynôme :</p>
<code>
𝑃(𝑥)= 𝑥<sup>24</sup> + 𝑥<sup>23</sup> + 𝑥<sup>22</sup> + 𝑥<sup>21</sup> + 𝑥<sup>20</sup> + 𝑥<sup>19</sup> + 𝑥<sup>18</sup> + 𝑥<sup>17</sup> + 𝑥<sup>16</sup> + 𝑥<sup>15</sup> + 𝑥<sup>14</sup> + 𝑥<sup>13</sup> + 𝑥<sup>12</sup> + 𝑥<sup>10</sup> + 𝑥<sup>3</sup> + 1
</code>
<p style="text-align:justify;">Le message binaire est alors transmis au serveur à l’aide de la bibliothèque de messagerie asynchrone zero-mq.</p><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="rustracker-1"><a class="header" href="#rustracker-1">Rustracker</a></h1>
<p style="text-align:justify;">Le serveur est chargé du traitement des messages binaires qui sont reçus par une ou plusieurs sources. </p>
<p style="text-align:justify;">Lorsque l’on reçoit un squitter, on commence par le découper dans le stocker sous forme de struct squitter, qui dispose de méthode permettant d’en récupérer les différentes sections.</p>
<p style="text-align:justify;">A partir de son code OACI, on va associer le squitter à un nouvel objet avion (la struct plane), qui a pour attribut l’ensemble des informations utiles associées à un avion. Chaque avion sera ensuite stocké dans une hashmap ayant pour clef son code OACI. Associé un nouveau squitter reçu à un avion déjà existant dans notre structure de donnée sera alors plus efficace.</p>
<p style="text-align:justify;">Une fois le squitter lié à l’avion, on en extrait les informations. En l’occurrence nous traitons 3 types de données : altitude, vitesse, et numéro de vol. Nous allons détailler séparément leurs analyses dans la section suivante.</p>
<h1 id="opérationabilité"><a class="header" href="#opérationabilité">Opérationabilité</a></h1>
<p style="text-align:justify;">Maintenant que nous avons une structure de donnée avec toutes les informations exploitables, il faut pouvoir la rendre opérationnelle, c’est-à-dire que l’on soit en mesure de créer une carte interactive des avions. Nous avons fait le choix que le programme génère un geojson qui pourra être lu de manière passive par notre interface graphique.</p>
<p>Pour ce faire, on fait face à plusieurs enjeux :</p>
<ul>
<li>
<p>Pouvoir générer ce geojson à intervalle régulier, sans interrompre le processus de réception
des squitter.</p>
</li>
<li>
<p>Être capable de retirer les avions qui sortis de notre champ de réception depuis un certains
temps.</p>
</li>
</ul>
<p style="text-align:justify;">Pour ces deux problèmes, nous avons décider d’utiliser de la programmation asynchrone. Deux threads vont être capables de communiquer avec le thread principal de réception des messages à travers des channels.</p>
<p style="text-align:justify;">Le premier thread est chargé de gérer la durée de vie des avions. Il envoie un signal à notre thread principal toute les 30 secondes, dès que le thread principal reçoit ce signal, il va parcourir la hashmap contenant chaque avion, et mesurer depuis combien de temps il n’a pas reçu de nouveaux messages depuis plus de 30 secondes, alors on considère que l’avion est sorti de notre champ de réception, et est donc retiré de notre mémoire.</p>
<p style="text-align:justify;">Le second thread lui génère le geojson. Un package de Rust spécialement créer pour les geojson propose une struct dans laquelle on stocke nos avions (avec moins d’information que notre struct plane détaillé plutôt, on ne mettra dans le geojson seulement celle utiles à l’interface graphique) et qui grâce à une méthode de conversion en string de cette struct, nous permet d’éditer le contenu de notre plane.geojson.</p><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="vitesse"><a class="header" href="#vitesse">Vitesse</a></h1>
<p>Les messages portant les informations de vitesses ont un type-code égal à 19.</p>
<p>Les messages de vitesse sont contitués de la manière suivante : </p>
<table><thead><tr><th></th><th>MSG</th><th>BITS</th></tr></thead><tbody>
<tr><td><strong>Type Code</strong></td><td>1-5</td><td>5</td></tr>
<tr><td><strong>Sub-Type</strong></td><td>6-8</td><td>3</td></tr>
<tr><td><strong>Intent change flag</strong></td><td>9</td><td>1</td></tr>
<tr><td><strong>IFR capability flag</strong></td><td>10</td><td>1</td></tr>
<tr><td><strong>Navigation uncertainty category for velocity</strong></td><td>11-13</td><td>3</td></tr>
<tr><td><strong>Sub-Type specific fields</strong></td><td>14-35</td><td>22</td></tr>
<tr><td><strong>Source bit for vertical rate</strong></td><td>36</td><td>1</td></tr>
<tr><td><strong>Sign bit for vertical rate</strong></td><td>37</td><td>1</td></tr>
<tr><td><strong>Vertical rate</strong></td><td>38-46</td><td>9</td></tr>
<tr><td><strong>Reserved</strong></td><td>47-48</td><td>2</td></tr>
<tr><td><strong>Sign bit for GNSS and Baro altitudes difference</strong></td><td>49</td><td>1</td></tr>
<tr><td><strong>Difference between GNSS and Baro altitudes</strong></td><td>50-56</td><td>7</td></tr>
</tbody></table>
<p>Dans le cadre de notre travail, tous ces champs ne sont pas utiles. On s'interresse particulièrement aux champs concernant la vitesse, la vitesse verticale ainsi que l'angle de piste des avions.</p>
<p>Les différents sous-types (Sub-type) permettent de distinguer les types de vitesses enregistrés ainsi que les types des avions (subsonniques et supersonniques).</p>
<table><thead><tr><th><strong>Sub-Type</strong></th><th>Type vitesse</th><th>Type avion</th></tr></thead><tbody>
<tr><td><strong>1</strong></td><td>GS</td><td>Subsonnic</td></tr>
<tr><td><strong>2</strong></td><td>GS</td><td>Supersonnic</td></tr>
<tr><td><strong>3</strong></td><td>TAS or IAS</td><td>Subsonnic</td></tr>
<tr><td><strong>4</strong></td><td>TAS or IAS</td><td>Supersonnic</td></tr>
</tbody></table>
<p>On distingue plusieurs types de vitesses : </p>
<p style="text-align:justify;">
<ul>
  <li> <p style="text-align:justify;"> <b>Indicated Air Speed (IAS) </b> = vitesse indiquée, c'est la vitesse directement lue dans le cockpit de l'avion, elle est mesurée grâce à des capteurs de pression et varie donc en fonction de l'altitude (baisse lorsque l'altitude augmente); </p></li>
  <li> <p style="text-align:justify;"> <b>True Air Speed (TAS) </b>= c'est la vitesse réelle de l'avion relativement à l'air qui l'entoure;</p> </li>
  <li><p style="text-align:justify;"> <b>Ground Speed (GS) </b> = vitesse au sol, il s'agot de la vitesse réelle corrigée qui prend compte des vents.</p>
</li>
</ul> 
</p>
<p style="text-align:justify;">
<p>Puisque qu'il n'y a actuellement plus d'avions supersonniques en circulation (retrait du concorde en 2003), les sous-types 2 et 4 n'ont pour l'instant pas d'utilité. </p></p>
<h2 id="décodage-vitesse"><a class="header" href="#décodage-vitesse">Décodage vitesse</a></h2>
<h3 id="sous-type-1"><a class="header" href="#sous-type-1">Sous-type 1</a></h3>
<p>La partie du message de vitesse utile pour le décodage de la vitesse sont les bits 14 à 35 décomposés de la manière suivante : </p>
<table><thead><tr><th></th><th></th><th><strong>MSG</strong></th><th><strong>BITS</strong></th></tr></thead><tbody>
<tr><td><strong>Direction pour la composante de vitesse E-O</strong></td><td>Dew</td><td>14</td><td>1</td></tr>
<tr><td><strong>Composante de vitesse Est-Ouest</strong></td><td>Vew</td><td>15-24</td><td>10</td></tr>
<tr><td><strong>Direction pour la composante de vitesse N-S</strong></td><td>Dns</td><td>25</td><td>1</td></tr>
<tr><td><strong>Composante de vitesse Nord-Sud</strong></td><td>Vns</td><td>26-35</td><td>10</td></tr>
</tbody></table>
<p style="text-align:justify;">
<p>On calcule la vitesse à partir des composantes Vew et Vns ainsi que des directions Dew et Dns.</p>
<p>On calcule également le track angle (angle de piste) qui permet d'orienter les avions sur la carte à l'aide de ces valeurs.</p>
</p>
<h3 id="sous-type-3"><a class="header" href="#sous-type-3">Sous-type 3</a></h3>
<p style="text-align:justify;">
<p>Les messages de sous-type 3 sont émis lorsque la vitesse au sol de l'avion n'est pas connue (par exemple quand le positionnement par satellite n'est pas disponible). Dans ce cas, la vitesse et le track angle sont directement encodés dans le message de la manière suivante : </p>
</p>
<table><thead><tr><th></th><th></th><th><strong>MSG</strong></th><th><strong>BITS</strong></th></tr></thead><tbody>
<tr><td><strong>Bit de status pour le cap magnétique</strong></td><td>SH</td><td>14</td><td>1</td></tr>
<tr><td><strong>Cap magnétique</strong></td><td>HDG</td><td>15-24</td><td>10</td></tr>
<tr><td><strong>Type de vitesse (IA or TAS)</strong></td><td>T</td><td>25</td><td>1</td></tr>
<tr><td><strong>Vitesse</strong></td><td>AS</td><td>26-35</td><td>10</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="trackui"><a class="header" href="#trackui">Trackui</a></h1>
<p style="text-align:justify;">L’interface graphique est codée en JavaScript. On utilise Leaflet qui est un package permettant de générer une carte. Cette carte affiche en temps réel les avions dont la position est partagée.</p>
<p style="text-align:justify;">Cependant comme ce n’est pas toujours le cas (selon le type de transpondeur de l’avion), et afin de présenter les informations supplémentaires tel que le numéro de vol, l’altitude et la vitesse, on a fait le choix d’ajouter un tableau contenant la liste des avions.</p>
<p style="text-align:justify;">De plus, ce tableau dispose de code OACI « cliquable » pour les avions dont la position est visible sur la carte. Lorsque l’on clique sur un bouton, la carte se recentre alors sur l’avion sélectionné et affiche son icone et sa trajectoire dans une couleur différente afin de le mettre en valeur.</p>
<p style="text-align:justify;">Enfin, la collecte des informations se fait en récupérant les informations du geojson généré par Rustracker toutes les 1,5 secondes. Le geojson est une FeatureCollection qui regroupe plusieurs Features qui sont nos avions. Ces Features ont pour ID le code OACI, et sont des LineString, c’est-à-dire que le champs geometry contient l’ensemble des points qui composent la trajectoire, puis dispose en attribut du reste des informations de l’avion.</p>
<p style="text-align:justify;">En itérant sur toutes les Feature, on ajoute pour chacune un calque à la carte qui affiche la trajectoire, et l’icone que l’on oriente grâce au « track angle » (la route suivie par l’avion). Chacun de ses calques sont dans un même groupe de calque.</p>
<p style="text-align:justify;">
A chaque nouvelle réception des données du geojson, on vide alors ce groupe de calque afin de le reremplir avec les informations actualisées</p><div style="break-before: page; page-break-before: always;"></div><h1 id="virtual-machine"><a class="header" href="#virtual-machine">Virtual Machine</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storyline"><a class="header" href="#storyline">Storyline</a></h1>
<p>The original retro planning was:</p>
<p><img src="images/retroplan.png" alt="Retro Planning" /></p>
<p>But over the project difficulties forced us to change the devellopment organization.</p>
<p>During the first meeting, on 27/01/22, the team discuss about the objectives about the project and the reports. The software structure has also been determined that day.
We chos the Rust programming language because it's </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h1>
<p>All the project goals have been completed in time. The software is completely working, the managed to learn a new programming language and to overcom difficulties during the devellopment.</p>
<h3 id="contributeurs"><a class="header" href="#contributeurs">Contributeurs</a></h3>
<p>Les quatre étudiants de Télécom SudParis ayant contribués au projet sont : </p>
<ul>
<li><a href="https://github.com/Witaek">Romain Amédée</a></li>
<li><a href="https://github.com/ArthurChauve">Arthur Chauve</a></li>
<li><a href="https://github.com/GuilhemHnr">Guilhem Honoré</a></li>
<li><a href="https://github.com/blaaass">Bastian Larvor</a></li>
</ul>
<p>Un grand merci à <a href="https://github.com/rgrunbla">Rémy Grünblatt</a> pour ses conseils et son aide.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
