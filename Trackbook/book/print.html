<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content=" The Trackbook describes the structures and goals of the RusTracker project">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded "><a href="prerequis.html"><strong aria-hidden="true">1.</strong> PrÃ©requis</a></li><li class="chapter-item expanded "><a href="architecture.html"><strong aria-hidden="true">2.</strong> Architecture</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Guide d'utilisation</li><li class="chapter-item expanded affix "><li class="part-title">Contexte</li><li class="chapter-item expanded "><a href="contexte.html"><strong aria-hidden="true">3.</strong> Set up</a></li><li class="chapter-item expanded affix "><li class="part-title">Source</li><li class="chapter-item expanded "><a href="source/reception.html"><strong aria-hidden="true">4.</strong> Source</a></li><li class="chapter-item expanded "><a href="source/setup.html"><strong aria-hidden="true">5.</strong> Set up</a></li><li class="chapter-item expanded affix "><li class="part-title">Rustracker</li><li class="chapter-item expanded "><a href="rustracker/index.html"><strong aria-hidden="true">6.</strong> Rustracker</a></li><li class="chapter-item expanded "><a href="rustracker/position.html"><strong aria-hidden="true">7.</strong> Position</a></li><li class="chapter-item expanded "><a href="rustracker/vitesse.html"><strong aria-hidden="true">8.</strong> Vitesse</a></li><li class="chapter-item expanded "><a href="rustracker/callsign.html"><strong aria-hidden="true">9.</strong> callsign</a></li><li class="chapter-item expanded affix "><li class="part-title">Trackui</li><li class="chapter-item expanded "><a href="trackui/index.html"><strong aria-hidden="true">10.</strong> Trackui</a></li><li class="chapter-item expanded "><a href="trackui/vm.html"><strong aria-hidden="true">11.</strong> Machine Virtuelle</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Test Results</li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="story.html">Project Storyline</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="conclusion.html">Conclusion</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p style="text-align:justify;">Lâ€™ADS-B (Automatic Dependent Surveillance-Broadcast) est un systÃ¨me de contrÃ´le du
trafic aÃ©rien. Un avion utilisant lâ€™ADS-B dÃ©termine sa position par un systÃ¨me de positionnement satellite et
la renvoit cette derniÃ¨re (ainsi que dâ€™autres informations sur le vol, altitude, vitesse, modÃ¨le de lâ€™avion, etc)
dans toutes les directions aux autres appareils disposant de lâ€™ADS-B. Ces messages sont dÃ©tectables, puis
dÃ©modulables, par toute personne Ã  lâ€™aide dâ€™une clef TNT (tuner RTL2832U, 15â‚¬), utilisÃ©e en SDR (Software Defined Radio),
qui permet de dÃ©finir les paramÃ¨tres de rÃ©ception, comme par exemple la frÃ©quence,
depuis lâ€™ordinateur. Lâ€™objectif du projet est dâ€™utiliser ces messages envoyÃ©s par les avions, et de proposer
une interface graphique Ã  lâ€™utilisateur. Sur cette interface, on souhaite observer en temps rÃ©el lâ€™ensemble
des avions Ã  portÃ©e de notre antenne ; nous souhaitons Ã©galement pouvoir observer la trajectoire des avions
ainsi que connaÃ®tre les informations sur le vol (altitude, vitesse, moteur, ...).</p>
<h3 id="description-du-livrable-minimal-"><a class="header" href="#description-du-livrable-minimal-">Description du livrable minimal :</a></h3>
<ul>
<li>Intercepter, dÃ©moduler, interprÃ©ter des signaux ADS-B envoyÃ©s par plusieurs avions</li>
<li>En extraire des informations sur la position, vitesse, modÃ¨le,...</li>
<li>Utiliser ces donnÃ©es pour gÃ©nÃ©rer en temps rÃ©el une carte sur laquelle figurent les avions</li>
<li>PossibilitÃ© dâ€™obtenir les informations concernant le vol des avions sÃ©lectionnÃ©s</li>
</ul>
<br/>
<p style="text-align: center;">
<img  typeof="foaf:Image" src="images/exemple.png"  width="350" height="350" alt="" title="Foto: Edis Å kulj/fkmladost.ba">  
</p>
<p style="text-align: center;">
    <b> Exemple de carte recherchÃ©e (FlightRadar24) </b>
</p>
<h3 id="description-brÃ¨ve-"><a class="header" href="#description-brÃ¨ve-">Description brÃ¨ve :</a></h3>
<p>Ce projet est dÃ©composÃ©e en trois parties communicantes les unes avec les autres : Source, Rustracker et TrackUI.</p>
<p style="text-align:justify;">
<ul>
  <li> <p style="text-align:justify;"> <b>Source</b> : c'est le programme chargÃ© d'intercepter les signaux ADS-B Ã©mis par les avions Ã  1090MHz. Il procÃ¨de ensuite de les dÃ©moduler (rÃ©ception sous forme de I&Qs), de les convertir en binaire et les envoit, grÃ¢ce au protocole TCP, Ã  Rustracker. </p></li>
  <li> <p style="text-align:justify;"> <b>Rustracker</b>: c'est le programme principal, stockÃ© sur une machine virtuelle, qui rÃ©cupÃ¨re les signaux sous forme binaire Ã©mis par Source, les interprÃ¨te afin d'en extraire les informations sur le vol des avions (position, vitesse, altitude, numÃ©ro de vol, etc). Il Ã©crit toutes ces informations dans un fichier geojson qui sera lu par Trackui. </p> </li>
  <li><p style="text-align:justify;"> <b>Trackui</b>: il s'agit de l'interface graphique de notre travail, sous forme de page web, herbergÃ©e par un serveur nginx sur la machine virtuelle Ã©voquÃ©e plus tÃ´t. Elle consulte Ã  intervalles de temps rÃ©gulier le fichier geojson mis Ã  disposition par Rustracker et affiche les avions en consÃ©quences sur la carte, les autres donnÃ©es concernant les avions sont regroupÃ©es dans un tableau Ã  cÃ´tÃ© de la carte.</p>
</li>
</ul> 
</p><div style="break-before: page; page-break-before: always;"></div><h1 id="prÃ©requis"><a class="header" href="#prÃ©requis">PrÃ©requis</a></h1>
<h2 id="rust"><a class="header" href="#rust">Rust</a></h2>
<p>Afin de faire tourner nos diffÃ©rents programmes (Source &amp; Rustracker), il est nÃ©cessaire d'installer le gestionnaire de paquet rust &quot;Cargo&quot; ainsi que le gestionnaire des chaÃ®nes d'outils &quot;rustup&quot;.</p>
<pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<br/>
<hr />
<h2 id="source"><a class="header" href="#source">Source</a></h2>
<p style="text-align:justify;">Afin de faire fonctionner Source,  il est nÃ©cessaire de correctement configurer les drivers pour utiliser les antennes RTL-SDR correctement. On propose ici un guide afin d'effectuer correctement les installations nÃ©cessaires au bon fonctionnement de Source.</p>
<h4 id="blacklist-des-pilotes"><a class="header" href="#blacklist-des-pilotes">Blacklist des pilotes</a></h4>
<p>CommenÃ§ons par connecter le dongle TNT Ã  l'ordinateur.</p>
<p>--&gt; La commande <code>dsemg</code> permet de vÃ©rifier que le dongle est bien connectÃ©.</p>
<p>Nous allons maintenant blacklister le pilote permettant de regarder la TNT avec le dongle afin qu'il n'interfÃ¨re pas dans le bon fonctionnement de notre programme.</p>
<pre><code>~ $ cd /etc/modprobe.d
/etc/modprobe.d $ sudo nano rtlsdr.conf
</code></pre>
<p>Rajoutons la ligne suivante dans le fichier rtlsdr.conf :</p>
<blockquote>
<p>blacklist dvb_usb_rtl28xxu</p>
</blockquote>
<p>Sauvegardons ensuite rtlsdr.conf.</p>
<p>--&gt; La commande <code>lsmod</code> permet de vÃ©rifier si le pilote est chargÃ©</p>
<p>Enfin, supprimons le pilote dÃ©jÃ  chargÃ©.</p>
<pre><code>~ $ blacklist dvb_usb_rtl28xxu
</code></pre>
<h4 id="installation-des-pilotes"><a class="header" href="#installation-des-pilotes">Installation des pilotes</a></h4>
<p>CommenÃ§ons par installer la librairie nÃ©cessaire Ã  l'utilisation de SoapySDR, la crate que nous utilisons afin d'utiliser les dongles rtlsdr avec notre code RUST.</p>
<pre><code>sudo apt install libsoapysdr-dev libclang-dev llvm-dev pkg-config
</code></pre>
<p>On installe ensuite le pilote correspondant.</p>
<pre><code>sudo apt install soapysdr-module-rtlsdr
</code></pre>
<p>Enfin on installe le plugin Soapy pour RTL-SDR.</p>
<pre><code>git clone https://github.com/pothosware/SoapyRTLSDR.git
cd SoapyRTLSDR
mkdir build
cd build
cmake ..
make
sudo make install
</code></pre>
<br/>
<hr />
<h2 id="rustracker"><a class="header" href="#rustracker">Rustracker</a></h2>
<p>L'installation de certaines librairies est nÃ©cessaires au bon fonctionnement du programme Rustracker.</p>
<p>Installons d'abord une librairie permettant d'utiliser pkg-config, un programme de gestion des librairies.</p>
<pre><code>sudo apt install pkg-config
</code></pre>
<p>On installe ensuite la librairie ZeroMQ que l'on utiliser pour les communications tcp entre Source et Rustracker.</p>
<pre><code>sudo apt install libzmq3-dev
</code></pre>
<p>Enfin, on installe deux packages nÃ©cessaires Ã  la compilation.</p>
<pre><code>sudo apt install build-essential
sudo apt install cmake</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="format"><a class="header" href="#format">Format</a></h1>
<p>Notre projet s'est divisÃ© en trois grande partie :</p>
<ol>
<li>La rÃ©ception des messages : Source</li>
<li>Leur traitement : Rustracker</li>
<li>Leur affichage dans une interface graphique : Trackui</li>
</ol>
<p style="text-align:justify;"> 
L'intÃ©raction entre ces trois parties est prÃ©sentÃ©e dans le diagramme suivant qui facilitera la comprÃ©hension de l'architecture du projet que nous allons vous prÃ©senter. </p>
<p><img src="images/rustracker.png" alt="Diagramme rustracker" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contexte"><a class="header" href="#contexte">Contexte</a></h1>
<p style="text-align:justify;">
Le rÃ©sultat finale prÃ©sente sous forme de carte interactive des avions, toutefois, lâ€™information a suivit un long processus avant de pouvoir Ãªtre prÃ©sentÃ©e sous une forme comprÃ©hensible pour lâ€™utilisateur.</p>
<p>Nous allons donc nous intÃ©resser au voyage dâ€™un message ADS-B.</p>
<p style="text-align:justify;"> 
Comme nous lâ€™avons spÃ©cifiÃ© en introduction, lâ€™*Automatic Dependent Surveillance-Broadcast* (ADS-B) est un mode de communication qui sert au contrÃ´le aÃ©rien.
</p>
Les deux premiÃ¨res lettres de lâ€™acronyme permettent de comprendre les enjeux du formatage et du mode de transmission des messages.
<p style="text-align:justify;"> 
*Â« Automatic Â»* signifie que les messages sont envoyÃ©s automatiquement, il nâ€™est pas nÃ©cessaire de solliciter le transpondeur de lâ€™avion pour obtenir une rÃ©ponse (ce qui se fait dans dâ€™autre mÃ©thode de contrÃ´le aÃ©rien). Cela impose donc aussi dâ€™avoir un programme suffisamment performant pour soutenir les flows de messages.
</p>
<p style="text-align:justify;"> 
*Â« Dependent Â»* caractÃ©rise la provenance de ces informations. Tout est transmis par lâ€™avion lui-mÃªme. Par exemple pour sa position, il la dÃ©fini Ã  partir de son systÃ¨me GPS embarquÃ© avant de la transmettre. Lâ€™implication directe concerne le formatage des messages : il faut, dans un nombre de bits limitÃ©s, transmettre suffisamment dâ€™informations pour lier le message Ã  lâ€™avion et donner des informations suffisamment prÃ©cises, et diverses (positions, vitesse, numÃ©ro de vol, â€¦)
</p>
<h1 id="format-1"><a class="header" href="#format-1">Format</a></h1>
<p>Ainsi, le format dâ€™un message ADS-B se prÃ©sente sous la forme suivante :</p>
<p>Il comporte 112 bits, divisÃ©s en parties distinctes, chacune portant des informations spÃ©cifiques :</p>
<p style="text-align:justify;">
<ul>
  <li> <p style="text-align:justify;"> 
<p><b>[0 ; 4] : Downlink format :</b>  Câ€™est le format de transmission, on ne sâ€™intÃ©resse ici quâ€™au 17, qui est le plus largement utilisÃ© dans lâ€™aviation civile. </p></li></p>
<li> <p style="text-align:justify;"> 
  <b>[5 ; 7] : Capability : </b> Câ€™est un champ Ã  utilisation technique que lâ€™on traite techniquement dans le programme mais dont lâ€™utilitÃ© pour un utilisateur lambda est faible, le rÃ©sultat nâ€™est donc pas prÃ©sentÃ© dans lâ€™interface graphique (il permet dâ€™obtenir notamment lâ€™importance des tourbillons marginaux crÃ©Ã©s par lâ€™avion, qui sont un phÃ©nomÃ¨ne dangereux pour un autre avion situÃ© derriÃ¨re, et est donc utilisÃ© par les contrÃ´leurs pour assurer une bonne sÃ©paration.</p> </li>
  <li><p style="text-align:justify;"> 
  <b>[8 ; 31] : adresse ICAO :</b>Câ€™est lâ€™Ã©lÃ©ment le plus important du message, il sâ€™agit dâ€™un code hexadÃ©cimal et unique Ã  lâ€™avion tout au long de sa Â« vie Â». Ce code Ã©tant unique et se trouvant dans tous les messages, câ€™est lui qui va permettre de lier des messages reÃ§us indÃ©pendamment Ã  lâ€™avion Ã©metteur.
</p>
</li>
 <li><p style="text-align:justify;"> 
 <b>[32 ; 87] : data : </b> Ces 56 bits sont le cÅ“ur du message, câ€™est eux qui transportent lâ€™information spÃ©cifique au vol Ã  lâ€™instant t. Les 5 premiers correspondent au Â« Type Code Â», qui nous indique le type de data reÃ§u. Il peut sâ€™agir de la vitesse, de la position, ou du numÃ©ro de vol, dont les formatages peuvent varier (nous le dÃ©taillerons plus tard).</p>
</li>
 <li><p style="text-align:justify;"> 
 <b>[88 ; 111] : CRC :</b>Ces derniers bits correspondent au contrÃ´le de redondance cyclique (CRC). Ils sont calculÃ©s Ã  lâ€™Ã©mission de faÃ§on Ã  ce quâ€™une opÃ©ration logique sur lâ€™ensemble des 112 bits donne un rÃ©sultat spÃ©cifique, permettant ainsi de valider lâ€™intÃ©gritÃ© du message reÃ§u. En effet, on reÃ§oit de nombreux messages mais entre lâ€™avion et notre antenne de rÃ©ception, ils ont pu Ãªtre dÃ©gradÃ©s dâ€™une telle faÃ§on que lâ€™information transportÃ©e est erronÃ©e. </p>
</li>
</ul> 
</p>
<p style="text-align:justify;"> 
Maintenant que lâ€™on connait ce quâ€™est un message ADS-B, nous allons pouvoir Ã©tudier tout son cheminement. Nous utiliserons par la suite le terme anglais de Squitter pour dÃ©signer un tel message.
</p><div style="break-before: page; page-break-before: always;"></div><h1 id="source-1"><a class="header" href="#source-1">Source</a></h1>
<p style="text-align:justify;">La rÃ©ception des squitter se fait de faÃ§on indÃ©pendante de leur traitement dans un programme Rust nommÃ© Â« Source Â».
<p>Le principe est dâ€™installer ce programme sur une station (dans notre cas un raspberry pi) dont le but est de capter le signal et de le transmettre au serveur.</p>
<p style="text-align:justify;">
Le squitter est dâ€™abords Ã©mis par lâ€™avion omnidirectionnellement sur la frÃ©quence de 1090MH, il voyage alors Ã  travers lâ€™atmosphÃ¨re avant dâ€™Ãªtre rÃ©ceptionnÃ© par notre antenne. Lâ€™onde de 1090Mhz est alors Ã©chantillonnÃ©e Ã  lâ€™aide un Dongle DVB-T pourvu dâ€™une puce <b>RTL2832U</b>. Originellement destinÃ© Ã  Ãªtre utilisÃ© pour la rÃ©ception de la TNT (â‰ˆ20â‚¬), lâ€™utilisations de drivers diffÃ©rents permet de le convertir en systÃ¨me SDR (Software Define Radio), dont on peut choisir la frÃ©quence de rÃ©ception.</p>
<p style="text-align:justify;">
Nous avons fait le choix dâ€™utiliser Soapy SDR (disponible en package pour Rust), qui permet Ã  lâ€™aide de simple ligne de code de se connecter au dongle et de choisir le taux dâ€™Ã©chantillonnage, la frÃ©quence de rÃ©ception et le gain. </p>
<p style="text-align:justify;">
Lâ€™onde est modulÃ©e en quadrature (I&Q), le rÃ©sultat est donc sous forme de complexe, que lâ€™on dÃ©module en prenant le module. A partir de lÃ , on dispose de lâ€™onde, toutefois il faut encore identifier les messages ads-b situÃ©s dans lâ€™Ã©chantillon. Ils sont Ã©chantillonnÃ©s Ã  une frÃ©quence : </p>
<p style="text-align: center;">
<code>
 fe = 2.10<sup>6</sup> Hz (soit Te = 500 ns)
 </code> </p>
 <p style="text-align:justify;">Sachant quâ€™il faut deux amplitudes pour coder un bit, la durÃ©e totale dâ€™un message est de 112 microsecondes. Pour identifier le dÃ©but du squitter on sâ€™appuie sur la dÃ©tection du prÃ©ambule. Il sâ€™agit dâ€™un motif caractÃ©ristique (cf. image). Il existe plusieurs moyens de dÃ©tecter un prÃ©ambule (cf. bibliographie), nous avons utiliser la dÃ©tection logique du prÃ©ambule. Le but de cette mÃ©thode est dâ€™identifier par des opÃ©rations logiques (<, >) les successions dâ€™amplitudes sur lâ€™onde sâ€™apparentant au motif (cf. figure prÃ©ambule)</p>
<p style="text-align: center;">
<img  typeof="foaf:Image" src="source/../images/preambule.jpg"  alt="" title="preambule">  
</p>
<p style="text-align:justify;">
Pour ce faire, on parcourt lâ€™Ã©chantillon de lâ€™onde, puis Ã  partir de lâ€™amplitude [i], on Ã©tablie une moyenne des valeurs Â« haute Â» ([i], [i+2], [i+7], [i+9]), puis on vÃ©rifie que toutes les autres valeurs jusquâ€™Ã  [i+15] sont infÃ©rieures aux valeurs hautes et vÃ©rifient les bonnes variations dâ€™amplitudes. </p>
<p style="text-align:justify;">
DÃ¨s que lâ€™on identifie un prÃ©ambule, on stocke les 224 points suivants de lâ€™Ã©chantillon pour les convertir en binaire selon la mÃ©thode suivante :
Chaque paire de points successives et dâ€™amplitudes (A1, A2) dÃ©finit un unique bit b tel que si A1>A2 alors b = 1, sinon b=0.</p>
<p>Nous obtenons enfin les 112 bits.</p>
<p>DÃ¨s lors, nous sommes en mesure de vÃ©rifier lâ€™intÃ©gritÃ© du message Ã  lâ€™aide du CRC.</p>
<p>Ce dernier se reprÃ©sente sous la forme dâ€™un polynÃ´me :</p>
<code>
ğ‘ƒ(ğ‘¥)= ğ‘¥<sup>24</sup> + ğ‘¥<sup>23</sup> + ğ‘¥<sup>22</sup> + ğ‘¥<sup>21</sup> + ğ‘¥<sup>20</sup> + ğ‘¥<sup>19</sup> + ğ‘¥<sup>18</sup> + ğ‘¥<sup>17</sup> + ğ‘¥<sup>16</sup> + ğ‘¥<sup>15</sup> + ğ‘¥<sup>14</sup> + ğ‘¥<sup>13</sup> + ğ‘¥<sup>12</sup> + ğ‘¥<sup>10</sup> + ğ‘¥<sup>3</sup> + 1
</code>
<p style="text-align:justify;">Le message binaire est alors transmis au serveur Ã  lâ€™aide de la bibliothÃ¨que de messagerie asynchrone zero-mq.</p><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="rustracker-1"><a class="header" href="#rustracker-1">Rustracker</a></h1>
<p style="text-align:justify;">Le serveur est chargÃ© du traitement des messages binaires qui sont reÃ§us par une ou plusieurs sources. </p>
<p style="text-align:justify;">Lorsque lâ€™on reÃ§oit un squitter, on commence par le dÃ©couper dans le stocker sous forme de struct squitter, qui dispose de mÃ©thode permettant dâ€™en rÃ©cupÃ©rer les diffÃ©rentes sections.</p>
<p style="text-align:justify;">A partir de son code OACI, on va associer le squitter Ã  un nouvel objet avion (la struct plane), qui a pour attribut lâ€™ensemble des informations utiles associÃ©es Ã  un avion. Chaque avion sera ensuite stockÃ© dans une hashmap ayant pour clef son code OACI. AssociÃ© un nouveau squitter reÃ§u Ã  un avion dÃ©jÃ  existant dans notre structure de donnÃ©e sera alors plus efficace.</p>
<p style="text-align:justify;">Une fois le squitter liÃ© Ã  lâ€™avion, on en extrait les informations. En lâ€™occurrence nous traitons 3 types de donnÃ©es : altitude, vitesse, et numÃ©ro de vol. Nous allons dÃ©tailler sÃ©parÃ©ment leurs analyses dans la section suivante.</p>
<h1 id="opÃ©rationabilitÃ©"><a class="header" href="#opÃ©rationabilitÃ©">OpÃ©rationabilitÃ©</a></h1>
<p style="text-align:justify;">Maintenant que nous avons une structure de donnÃ©e avec toutes les informations exploitables, il faut pouvoir la rendre opÃ©rationnelle, câ€™est-Ã -dire que lâ€™on soit en mesure de crÃ©er une carte interactive des avions. Nous avons fait le choix que le programme gÃ©nÃ¨re un geojson qui pourra Ãªtre lu de maniÃ¨re passive par notre interface graphique.</p>
<p>Pour ce faire, on fait face Ã  plusieurs enjeux :</p>
<ul>
<li>
<p>Pouvoir gÃ©nÃ©rer ce geojson Ã  intervalle rÃ©gulier, sans interrompre le processus de rÃ©ception
des squitter.</p>
</li>
<li>
<p>ÃŠtre capable de retirer les avions qui sortis de notre champ de rÃ©ception depuis un certains
temps.</p>
</li>
</ul>
<p style="text-align:justify;">Pour ces deux problÃ¨mes, nous avons dÃ©cider dâ€™utiliser de la programmation asynchrone. Deux threads vont Ãªtre capables de communiquer avec le thread principal de rÃ©ception des messages Ã  travers des channels.</p>
<p style="text-align:justify;">Le premier thread est chargÃ© de gÃ©rer la durÃ©e de vie des avions. Il envoie un signal Ã  notre thread principal toute les 30 secondes, dÃ¨s que le thread principal reÃ§oit ce signal, il va parcourir la hashmap contenant chaque avion, et mesurer depuis combien de temps il nâ€™a pas reÃ§u de nouveaux messages depuis plus de 30 secondes, alors on considÃ¨re que lâ€™avion est sorti de notre champ de rÃ©ception, et est donc retirÃ© de notre mÃ©moire.</p>
<p style="text-align:justify;">Le second thread lui gÃ©nÃ¨re le geojson. Un package de Rust spÃ©cialement crÃ©er pour les geojson propose une struct dans laquelle on stocke nos avions (avec moins dâ€™information que notre struct plane dÃ©taillÃ© plutÃ´t, on ne mettra dans le geojson seulement celle utiles Ã  lâ€™interface graphique) et qui grÃ¢ce Ã  une mÃ©thode de conversion en string de cette struct, nous permet dâ€™Ã©diter le contenu de notre plane.geojson.</p><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="vitesse"><a class="header" href="#vitesse">Vitesse</a></h1>
<p>Les messages portant les informations de vitesses ont un type-code Ã©gal Ã  19.</p>
<p>Les messages de vitesse sont contituÃ©s de la maniÃ¨re suivante : </p>
<table><thead><tr><th></th><th>MSG</th><th>BITS</th></tr></thead><tbody>
<tr><td><strong>Type Code</strong></td><td>1-5</td><td>5</td></tr>
<tr><td><strong>Sub-Type</strong></td><td>6-8</td><td>3</td></tr>
<tr><td><strong>Intent change flag</strong></td><td>9</td><td>1</td></tr>
<tr><td><strong>IFR capability flag</strong></td><td>10</td><td>1</td></tr>
<tr><td><strong>Navigation uncertainty category for velocity</strong></td><td>11-13</td><td>3</td></tr>
<tr><td><strong>Sub-Type specific fields</strong></td><td>14-35</td><td>22</td></tr>
<tr><td><strong>Source bit for vertical rate</strong></td><td>36</td><td>1</td></tr>
<tr><td><strong>Sign bit for vertical rate</strong></td><td>37</td><td>1</td></tr>
<tr><td><strong>Vertical rate</strong></td><td>38-46</td><td>9</td></tr>
<tr><td><strong>Reserved</strong></td><td>47-48</td><td>2</td></tr>
<tr><td><strong>Sign bit for GNSS and Baro altitudes difference</strong></td><td>49</td><td>1</td></tr>
<tr><td><strong>Difference between GNSS and Baro altitudes</strong></td><td>50-56</td><td>7</td></tr>
</tbody></table>
<p>Dans le cadre de notre travail, tous ces champs ne sont pas utiles. On s'interresse particuliÃ¨rement aux champs concernant la vitesse, la vitesse verticale ainsi que l'angle de piste des avions.</p>
<p>Les diffÃ©rents sous-types (Sub-type) permettent de distinguer les types de vitesses enregistrÃ©s ainsi que les types des avions (subsonniques et supersonniques).</p>
<table><thead><tr><th><strong>Sub-Type</strong></th><th>Type vitesse</th><th>Type avion</th></tr></thead><tbody>
<tr><td><strong>1</strong></td><td>GS</td><td>Subsonnic</td></tr>
<tr><td><strong>2</strong></td><td>GS</td><td>Supersonnic</td></tr>
<tr><td><strong>3</strong></td><td>TAS or IAS</td><td>Subsonnic</td></tr>
<tr><td><strong>4</strong></td><td>TAS or IAS</td><td>Supersonnic</td></tr>
</tbody></table>
<p>On distingue plusieurs types de vitesses : </p>
<p style="text-align:justify;">
<ul>
  <li> <p style="text-align:justify;"> <b>Indicated Air Speed (IAS) </b> = vitesse indiquÃ©e, c'est la vitesse directement lue dans le cockpit de l'avion, elle est mesurÃ©e grÃ¢ce Ã  des capteurs de pression et varie donc en fonction de l'altitude (baisse lorsque l'altitude augmente); </p></li>
  <li> <p style="text-align:justify;"> <b>True Air Speed (TAS) </b>= c'est la vitesse rÃ©elle de l'avion relativement Ã  l'air qui l'entoure;</p> </li>
  <li><p style="text-align:justify;"> <b>Ground Speed (GS) </b> = vitesse au sol, il s'agot de la vitesse rÃ©elle corrigÃ©e qui prend compte des vents.</p>
</li>
</ul> 
</p>
<p style="text-align:justify;">
<p>Puisque qu'il n'y a actuellement plus d'avions supersonniques en circulation (retrait du concorde en 2003), les sous-types 2 et 4 n'ont pour l'instant pas d'utilitÃ©. </p></p>
<h2 id="dÃ©codage-vitesse"><a class="header" href="#dÃ©codage-vitesse">DÃ©codage vitesse</a></h2>
<h3 id="sous-type-1"><a class="header" href="#sous-type-1">Sous-type 1</a></h3>
<p>La partie du message de vitesse utile pour le dÃ©codage de la vitesse sont les bits 14 Ã  35 dÃ©composÃ©s de la maniÃ¨re suivante : </p>
<table><thead><tr><th></th><th></th><th><strong>MSG</strong></th><th><strong>BITS</strong></th></tr></thead><tbody>
<tr><td><strong>Direction pour la composante de vitesse E-O</strong></td><td>Dew</td><td>14</td><td>1</td></tr>
<tr><td><strong>Composante de vitesse Est-Ouest</strong></td><td>Vew</td><td>15-24</td><td>10</td></tr>
<tr><td><strong>Direction pour la composante de vitesse N-S</strong></td><td>Dns</td><td>25</td><td>1</td></tr>
<tr><td><strong>Composante de vitesse Nord-Sud</strong></td><td>Vns</td><td>26-35</td><td>10</td></tr>
</tbody></table>
<p style="text-align:justify;">
<p>On calcule la vitesse Ã  partir des composantes Vew et Vns ainsi que des directions Dew et Dns.</p>
<p>On calcule Ã©galement le track angle (angle de piste) qui permet d'orienter les avions sur la carte Ã  l'aide de ces valeurs.</p>
</p>
<h3 id="sous-type-3"><a class="header" href="#sous-type-3">Sous-type 3</a></h3>
<p style="text-align:justify;">
<p>Les messages de sous-type 3 sont Ã©mis lorsque la vitesse au sol de l'avion n'est pas connue (par exemple quand le positionnement par satellite n'est pas disponible). Dans ce cas, la vitesse et le track angle sont directement encodÃ©s dans le message de la maniÃ¨re suivante : </p>
</p>
<table><thead><tr><th></th><th></th><th><strong>MSG</strong></th><th><strong>BITS</strong></th></tr></thead><tbody>
<tr><td><strong>Bit de status pour le cap magnÃ©tique</strong></td><td>SH</td><td>14</td><td>1</td></tr>
<tr><td><strong>Cap magnÃ©tique</strong></td><td>HDG</td><td>15-24</td><td>10</td></tr>
<tr><td><strong>Type de vitesse (IA or TAS)</strong></td><td>T</td><td>25</td><td>1</td></tr>
<tr><td><strong>Vitesse</strong></td><td>AS</td><td>26-35</td><td>10</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="trackui"><a class="header" href="#trackui">Trackui</a></h1>
<p style="text-align:justify;">Lâ€™interface graphique est codÃ©e en JavaScript. On utilise Leaflet qui est un package permettant de gÃ©nÃ©rer une carte. Cette carte affiche en temps rÃ©el les avions dont la position est partagÃ©e.</p>
<p style="text-align:justify;">Cependant comme ce nâ€™est pas toujours le cas (selon le type de transpondeur de lâ€™avion), et afin de prÃ©senter les informations supplÃ©mentaires tel que le numÃ©ro de vol, lâ€™altitude et la vitesse, on a fait le choix dâ€™ajouter un tableau contenant la liste des avions.</p>
<p style="text-align:justify;">De plus, ce tableau dispose de code OACI Â« cliquable Â» pour les avions dont la position est visible sur la carte. Lorsque lâ€™on clique sur un bouton, la carte se recentre alors sur lâ€™avion sÃ©lectionnÃ© et affiche son icone et sa trajectoire dans une couleur diffÃ©rente afin de le mettre en valeur.</p>
<p style="text-align:justify;">Enfin, la collecte des informations se fait en rÃ©cupÃ©rant les informations du geojson gÃ©nÃ©rÃ© par Rustracker toutes les 1,5 secondes. Le geojson est une FeatureCollection qui regroupe plusieurs Features qui sont nos avions. Ces Features ont pour ID le code OACI, et sont des LineString, câ€™est-Ã -dire que le champs geometry contient lâ€™ensemble des points qui composent la trajectoire, puis dispose en attribut du reste des informations de lâ€™avion.</p>
<p style="text-align:justify;">En itÃ©rant sur toutes les Feature, on ajoute pour chacune un calque Ã  la carte qui affiche la trajectoire, et lâ€™icone que lâ€™on oriente grÃ¢ce au Â« track angle Â» (la route suivie par lâ€™avion). Chacun de ses calques sont dans un mÃªme groupe de calque.</p>
<p style="text-align:justify;">
A chaque nouvelle rÃ©ception des donnÃ©es du geojson, on vide alors ce groupe de calque afin de le reremplir avec les informations actualisÃ©es</p><div style="break-before: page; page-break-before: always;"></div><h1 id="virtual-machine"><a class="header" href="#virtual-machine">Virtual Machine</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storyline"><a class="header" href="#storyline">Storyline</a></h1>
<p>The original retro planning was:</p>
<p><img src="images/retroplan.png" alt="Retro Planning" /></p>
<p>But over the project difficulties forced us to change the devellopment organization.</p>
<p>During the first meeting, on 27/01/22, the team discuss about the objectives about the project and the reports. The software structure has also been determined that day.
We chos the Rust programming language because it's </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h1>
<p>All the project goals have been completed in time. The software is completely working, the managed to learn a new programming language and to overcom difficulties during the devellopment.</p>
<h3 id="contributeurs"><a class="header" href="#contributeurs">Contributeurs</a></h3>
<p>Les quatre Ã©tudiants de TÃ©lÃ©com SudParis ayant contribuÃ©s au projet sont : </p>
<ul>
<li><a href="https://github.com/Witaek">Romain AmÃ©dÃ©e</a></li>
<li><a href="https://github.com/ArthurChauve">Arthur Chauve</a></li>
<li><a href="https://github.com/GuilhemHnr">Guilhem HonorÃ©</a></li>
<li><a href="https://github.com/blaaass">Bastian Larvor</a></li>
</ul>
<p>Un grand merci Ã  <a href="https://github.com/rgrunbla">RÃ©my GrÃ¼nblatt</a> pour ses conseils et son aide.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
