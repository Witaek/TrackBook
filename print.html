<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content=" The Trackbook describes the structures and goals of the RusTracker project">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded "><a href="prerequis.html"><strong aria-hidden="true">1.</strong> PrÃ©requis</a></li><li class="chapter-item expanded "><a href="architecture.html"><strong aria-hidden="true">2.</strong> Architecture</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Guide d'utilisation</li><li class="chapter-item expanded "><a href="guide.html"><strong aria-hidden="true">3.</strong> Guide</a></li><li class="chapter-item expanded affix "><li class="part-title">Contexte</li><li class="chapter-item expanded "><a href="contexte.html"><strong aria-hidden="true">4.</strong> ADS-B</a></li><li class="chapter-item expanded affix "><li class="part-title">Source</li><li class="chapter-item expanded "><a href="source/reception.html"><strong aria-hidden="true">5.</strong> Source</a></li><li class="chapter-item expanded "><a href="source/infrastructure.html"><strong aria-hidden="true">6.</strong> Infrastructure</a></li><li class="chapter-item expanded affix "><li class="part-title">Rustracker</li><li class="chapter-item expanded "><a href="rustracker/rustracker.html"><strong aria-hidden="true">7.</strong> Rustracker</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rustracker/position.html"><strong aria-hidden="true">7.1.</strong> Position</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rustracker/erreurs.html"><strong aria-hidden="true">7.1.1.</strong> Erreurs</a></li></ol></li><li class="chapter-item expanded "><a href="rustracker/vitesse.html"><strong aria-hidden="true">7.2.</strong> Vitesse</a></li><li class="chapter-item expanded "><a href="rustracker/callsign.html"><strong aria-hidden="true">7.3.</strong> Callsign</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Trackui</li><li class="chapter-item expanded "><a href="trackui/trackui.html"><strong aria-hidden="true">8.</strong> Trackui</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="story.html">Project Storyline</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="conclusion.html">Conclusion</a></li><li class="chapter-item expanded affix "><a href="bibliographie.html">Bibliographie</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p style="text-align:justify;">Lâ€™ADS-B (Automatic Dependent Surveillance-Broadcast) est un systÃ¨me de contrÃ´le du trafic aÃ©rien. Un avion utilisant lâ€™ADS-B dÃ©termine sa position par un systÃ¨me de positionnement satellite et renvoie cette derniÃ¨re (ainsi que dâ€™autres informations sur le vol, altitude, vitesse, modÃ¨le de lâ€™avion, etc) dans toutes les directions aux autres appareils disposant de lâ€™ADS-B. Ces messages sont dÃ©tectables, puis dÃ©modulables, par toute personne Ã  lâ€™aide dâ€™une clef TNT (tuner RTL2832U, 15â‚¬), utilisÃ©e en SDR (Software Defined Radio), qui permet de dÃ©finir les paramÃ¨tres de rÃ©ception (comme par exemple la frÃ©quence), depuis lâ€™ordinateur. Lâ€™objectif du projet est dâ€™utiliser ces messages envoyÃ©s par les avions, et de proposer une interface graphique Ã  lâ€™utilisateur. Sur cette interface, on souhaite observer en temps rÃ©el lâ€™ensemble des avions Ã  portÃ©e de notre antenne et leur trajectoire, ainsi que les informations sur le vol (altitude, vitesse, moteur, ...).</p>
<h3 id="description-du-livrable-minimal-"><a class="header" href="#description-du-livrable-minimal-">Description du livrable minimal :</a></h3>
<ul>
<li>Intercepter, dÃ©moduler, interprÃ©ter des signaux ADS-B envoyÃ©s par plusieurs avions</li>
<li>En extraire des informations sur la position, vitesse, modÃ¨le,...</li>
<li>Utiliser ces donnÃ©es pour gÃ©nÃ©rer en temps rÃ©el une carte sur laquelle figurent les avions</li>
<li>PossibilitÃ© dâ€™obtenir les informations concernant le vol des avions sÃ©lectionnÃ©s</li>
</ul>
<br/>
<p style="text-align: center;">
<img  typeof="foaf:Image" src="images/exemple.png"  width="350" height="350" alt="" title="Foto: Edis Å kulj/fkmladost.ba">  
</p>
<p style="text-align: center;">
    <b> Exemple de carte recherchÃ©e (FlightRadar24) </b>
</p>
<h3 id="description-brÃ¨ve-"><a class="header" href="#description-brÃ¨ve-">Description brÃ¨ve :</a></h3>
<p>Ce projet est dÃ©composÃ© en trois parties communicantes les unes avec les autres : Source, Rustracker et TrackUI.</p>
<p style="text-align:justify;">
<ul>
  <li> <p style="text-align:justify;"> <b>Source</b> : c'est le programme chargÃ© d'intercepter les signaux ADS-B Ã©mis par les avions Ã  1090MHz. Ensuite il les dÃ©module (rÃ©ception sous forme de I&Qs), les convertis en binaire et les envoi, grÃ¢ce au protocole TCP, Ã  Rustracker. </p></li>
  <li> <p style="text-align:justify;"> <b>Rustracker</b>: c'est le programme principal, stockÃ© sur une machine virtuelle, qui rÃ©cupÃ¨re les signaux sous forme binaire Ã©mis par Source, les interprÃ¨te afin d'en extraire les informations sur le vol des avions (position, vitesse, altitude, numÃ©ro de vol, etc). Il Ã©crit toutes ces informations dans un fichier geojson qui sera lu par Trackui. </p> </li>
  <li><p style="text-align:justify;"> <b>Trackui</b>: il s'agit de l'interface graphique de notre travail, sous forme de page web, herbergÃ©e par un serveur nginx sur la machine virtuelle Ã©voquÃ©e plus tÃ´t. Elle consulte Ã  intervalles de temps rÃ©guliers le fichier geojson mis Ã  disposition par Rustracker et affiche les avions en consÃ©quences sur la carte, les autres donnÃ©es concernant les avions sont regroupÃ©es dans un tableau Ã  cÃ´tÃ© de la carte.</p>
</li>
</ul> 
</p><div style="break-before: page; page-break-before: always;"></div><h1 id="prÃ©requis"><a class="header" href="#prÃ©requis">PrÃ©requis</a></h1>
<h2 id="rust"><a class="header" href="#rust">Rust</a></h2>
<p>Afin de faire fonctionner nos diffÃ©rents programmes (Source &amp; Rustracker), il est nÃ©cessaire d'installer le gestionnaire de paquet rust &quot;Cargo&quot; ainsi que le gestionnaire des chaÃ®nes d'outils &quot;rustup&quot;.</p>
<pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<br/>
<hr />
<h2 id="source"><a class="header" href="#source">Source</a></h2>
<p style="text-align:justify;">Afin de faire fonctionner Source,  il est nÃ©cessaire de configurer les drivers pour utiliser les dongles RTL-SDR correctement. On propose ici un guide afin d'effectuer les installations nÃ©cessaires au bon fonctionnement de Source.</p>
<h4 id="blacklist-des-pilotes"><a class="header" href="#blacklist-des-pilotes">Blacklist des pilotes</a></h4>
<p>CommenÃ§ons par connecter le dongle TNT Ã  l'ordinateur.</p>
<p>--&gt; La commande <code>dsemg</code> permet de vÃ©rifier que le dongle est bien connectÃ©.</p>
<p>Nous allons maintenant blacklister le pilote permettant de regarder la TNT avec le dongle afin qu'il n'interfÃ¨re pas dans le bon fonctionnement de notre programme.</p>
<pre><code>~ $ cd /etc/modprobe.d
/etc/modprobe.d $ sudo nano rtlsdr.conf
</code></pre>
<p>Rajoutons la ligne suivante dans le fichier rtlsdr.conf :</p>
<blockquote>
<p>blacklist dvb_usb_rtl28xxu</p>
</blockquote>
<p>Sauvegardons ensuite rtlsdr.conf.</p>
<p>--&gt; La commande <code>lsmod</code> permet de vÃ©rifier si le pilote est chargÃ©</p>
<p>Enfin, supprimons le pilote dÃ©jÃ  chargÃ©.</p>
<pre><code>~ $ blacklist dvb_usb_rtl28xxu
</code></pre>
<h4 id="installation-des-pilotes"><a class="header" href="#installation-des-pilotes">Installation des pilotes</a></h4>
<p>CommenÃ§ons par installer la librairie nÃ©cessaire Ã  l'utilisation de SoapySDR, le crate que nous utilisons afin d'utiliser les dongles rtlsdr avec notre code RUST.</p>
<pre><code>sudo apt install libsoapysdr-dev libclang-dev llvm-dev pkg-config
</code></pre>
<p>On installe ensuite le pilote correspondant.</p>
<pre><code>sudo apt install soapysdr-module-rtlsdr
</code></pre>
<p>Enfin on installe le plugin Soapy pour RTL-SDR.</p>
<pre><code>git clone https://github.com/pothosware/SoapyRTLSDR.git
cd SoapyRTLSDR
mkdir build
cd build
cmake ..
make
sudo make install
</code></pre>
<br/>
<hr />
<h2 id="rustracker"><a class="header" href="#rustracker">Rustracker</a></h2>
<p>L'installation de certaines librairies est nÃ©cessaire au bon fonctionnement du programme Rustracker.</p>
<p>Installons d'abord une librairie permettant d'utiliser pkg-config, un programme de gestion des librairies.</p>
<pre><code>sudo apt install pkg-config
</code></pre>
<p>On installe ensuite la librairie ZeroMQ que l'on utilise pour les communications tcp entre Source et Rustracker.</p>
<pre><code>sudo apt install libzmq3-dev
</code></pre>
<p>Enfin, on installe deux packages nÃ©cessaires Ã  la compilation.</p>
<pre><code>sudo apt install build-essential
sudo apt install cmake</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="format"><a class="header" href="#format">Format</a></h1>
<p>Notre projet est divisÃ© en trois grandes parties :</p>
<ol>
<li>La rÃ©ception des messages : Source</li>
<li>Leur traitement : Rustracker</li>
<li>Leur affichage dans une interface graphique web : Trackui</li>
</ol>
<p style="text-align:justify;"> 
L'intÃ©raction entre ces trois parties est prÃ©sentÃ©e dans le diagramme suivant qui facilitera la comprÃ©hension de l'architecture du projet que nous allons vous prÃ©senter. </p>
<p><img src="images/rustracker.png" alt="Diagramme rustracker" /></p>
<div style="break-before: page; page-break-before: always;"></div><p>La version complÃ¨te et fonctionnelle du projet peut Ãªtre observÃ©e sur le lien suivant <a href="http://rustracker.h.minet.net">RusTracker</a>.</p>
<p><img src="images/ui.png" alt="Interface" /></p>
<p>Ã€ gauche on trouve une carte oÃ¹ les avions sont affichÃ©s. Et Ã  droite les vols avec toutes leurs informations sont listÃ©s dans un tableau.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contexte"><a class="header" href="#contexte">Contexte</a></h1>
<p style="text-align:justify;">
Le rÃ©sultat final affiche sous forme de carte interactive des avions. Toutefois, lâ€™information a suivi un long processus avant de pouvoir Ãªtre prÃ©sentÃ©e sous une forme comprÃ©hensible pour lâ€™utilisateur.</p>
<p>Nous allons donc nous intÃ©resser au voyage dâ€™un message ADS-B.</p>
<p style="text-align:justify;"> 
Comme nous lâ€™avons spÃ©cifiÃ© en introduction, lâ€™<b>Automatic Dependent Surveillance-Broadcast</b> (ADS-B) est un mode de communication qui sert au contrÃ´le aÃ©rien.
</p>
Les deux premiÃ¨res lettres de lâ€™acronyme permettent de comprendre les enjeux du formatage et du mode de transmission des messages.
<p style="text-align:justify;"> 
<b>Â« Automatic Â»</b> signifie que les messages sont envoyÃ©s automatiquement, i.e. il nâ€™est pas nÃ©cessaire de solliciter le transpondeur de lâ€™avion pour obtenir une rÃ©ponse (ce qui se fait dans dâ€™autres mÃ©thodes de contrÃ´le aÃ©rien). Cela impose donc egalement dâ€™avoir un programme suffisamment performant pour soutenir les flows de messages.
</p>
<p style="text-align:justify;"> 
<b>Â« Dependent Â»</b> caractÃ©rise la provenance de ces informations. Tout est transmis par lâ€™avion lui-mÃªme. Par exemple pour sa position, il la dÃ©fini Ã  partir de son systÃ¨me GPS embarquÃ© avant de la transmettre. Lâ€™implication directe concerne le formatage des messages : il faut, dans un nombre de bits limitÃ©s, transmettre suffisamment dâ€™informations pour lier le message Ã  lâ€™avion et donner des informations suffisamment prÃ©cises, et diverses (positions, vitesse, numÃ©ro de vol, â€¦)
</p>
<h1 id="format-1"><a class="header" href="#format-1">Format</a></h1>
<p>Ainsi, le format dâ€™un message ADS-B se prÃ©sente sous la forme suivante :</p>
<p>Il comporte 112 bits, divisÃ©s en parties distinctes, chacune portant des informations spÃ©cifiques :</p>
<p style="text-align:justify;">
<ul>
  <li> <p style="text-align:justify;"> 
<p><b>[0 ; 4] : Downlink format :</b>  Câ€™est le format de transmission, on ne sâ€™intÃ©resse ici quâ€™au 17, qui est le plus largement utilisÃ© dans lâ€™aviation civile. </p></li></p>
<li> <p style="text-align:justify;"> 
  <b>[5 ; 7] : Capability : </b> Câ€™est un champ Ã  utilisation technique que lâ€™on traite en pratique dans le programme mais dont lâ€™utilitÃ© pour un utilisateur lambda est faible, le rÃ©sultat nâ€™est donc pas prÃ©sentÃ© dans lâ€™interface graphique (il permet dâ€™obtenir notamment lâ€™importance des tourbillons marginaux crÃ©Ã©s par lâ€™avion, qui sont un phÃ©nomÃ¨ne dangereux pour un autre avion situÃ© derriÃ¨re, et est donc utilisÃ© par les contrÃ´leurs pour assurer une bonne sÃ©paration).</p> </li>
  <li><p style="text-align:justify;"> 
  <b>[8 ; 31] : adresse ICAO :</b>Câ€™est lâ€™Ã©lÃ©ment le plus important du message, il sâ€™agit dâ€™un code hexadÃ©cimal et unique Ã  lâ€™avion tout au long de sa Â« vie Â». Ce code Ã©tant unique et se trouvant dans tous les messages, câ€™est lui qui va permettre de lier des messages reÃ§us indÃ©pendamment Ã  lâ€™avion Ã©metteur.
</p>
</li>
 <li><p style="text-align:justify;"> 
 <b>[32 ; 87] : data : </b> Ces 56 bits sont le cÅ“ur du message, ce sont eux qui transportent lâ€™information spÃ©cifique au vol Ã  lâ€™instant t. Les 5 premiers correspondent au Â« Type Code Â», qui nous indique le type de data reÃ§u. Il peut sâ€™agir de la vitesse, de la position, ou du numÃ©ro de vol, dont les formatages peuvent varier (nous le dÃ©taillerons plus tard).</p>
</li>
 <li><p style="text-align:justify;"> 
 <b>[88 ; 111] : CRC :</b>Ces derniers bits correspondent au contrÃ´le de redondance cyclique (CRC). Ils sont calculÃ©s Ã  lâ€™Ã©mission de faÃ§on Ã  ce quâ€™une opÃ©ration logique sur lâ€™ensemble des 112 bits donne un rÃ©sultat spÃ©cifique, permettant ainsi de valider lâ€™intÃ©gritÃ© du message reÃ§u. En effet, on reÃ§oit de nombreux messages mais entre lâ€™avion et notre antenne de rÃ©ception, ils ont pu Ãªtre dÃ©gradÃ©s dâ€™une telle faÃ§on que lâ€™information transportÃ©e est erronÃ©e. </p>
</li>
</ul> 
</p>
<p style="text-align:justify;"> 
Maintenant que lâ€™on connaÃ®t ce quâ€™est un message ADS-B, nous allons pouvoir Ã©tudier tout son cheminement. Nous utiliserons par la suite le terme anglais de Squitter pour dÃ©signer un tel message.
</p><div style="break-before: page; page-break-before: always;"></div><h1 id="source-1"><a class="header" href="#source-1">Source</a></h1>
<p style="text-align:justify;">La rÃ©ception des squitter se fait de faÃ§on indÃ©pendante de leur traitement dans un programme Rust nommÃ© Â« Source Â».
<p>Le principe est dâ€™installer ce programme sur une station (dans notre cas un raspberry pi) dont le but est de capter le signal et de le transmettre au serveur.</p>
<p style="text-align:justify;">
Le squitter est dâ€™abord Ã©mis par lâ€™avion omnidirectionnellement sur la frÃ©quence de 1090MHz, il voyage alors Ã  travers lâ€™atmosphÃ¨re avant dâ€™Ãªtre rÃ©ceptionnÃ© par notre antenne. Lâ€™onde de 1090Mhz est alors Ã©chantillonnÃ©e Ã  lâ€™aide d'un Dongle DVB-T pourvu dâ€™une puce <b>RTL2832U</b>. Initiallement destinÃ© Ã  la rÃ©ception de la TNT (â‰ˆ20â‚¬), lâ€™utilisation de drivers diffÃ©rents permet de le convertir en systÃ¨me SDR (Software Define Radio), dont on peut choisir la frÃ©quence de rÃ©ception.</p>
<p style="text-align:justify;">
Nous avons fait le choix dâ€™utiliser Soapy SDR (disponible en package pour Rust), qui permet Ã  lâ€™aide de simple lignes de code, de se connecter au dongle et de choisir le taux dâ€™Ã©chantillonnage, la frÃ©quence de rÃ©ception et le gain. </p>
<p style="text-align:justify;">
Lâ€™onde est modulÃ©e en quadrature (I&Q), le rÃ©sultat est obtenu sous forme de complexe, que lâ€™on dÃ©module en calculant le module. Ã€ partir de lÃ , on dispose de lâ€™onde, toutefois il faut encore identifier les messages ADS-B situÃ©s dans lâ€™Ã©chantillon. Ils sont Ã©chantillonnÃ©s Ã  une frÃ©quence : </p>
<p style="text-align: center;">
<code>
 fe = 2.10<sup>6</sup> Hz (soit Te = 500 ns)
 </code> </p>
 <p style="text-align:justify;">Sachant quâ€™il faut deux amplitudes pour coder un bit, la durÃ©e totale dâ€™un message est de 112 microsecondes. Pour identifier le dÃ©but du squitter on sâ€™appuie sur la dÃ©tection du prÃ©ambule. Il sâ€™agit dâ€™un motif caractÃ©ristique (cf. image). Il existe plusieurs moyens de dÃ©tecter un prÃ©ambule (cf. bibliographie), nous avons utilisÃ© sa dÃ©tection logique. Le but de cette mÃ©thode est dâ€™identifier par des opÃ©rations logiques (<, >) les successions dâ€™amplitudes sur lâ€™onde sâ€™apparentant au motif (cf. figure prÃ©ambule).</p>
<p style="text-align: center;">
<img  typeof="foaf:Image" src="source/../images/preambule.jpg"  alt="" title="preambule">  
</p>
<p style="text-align:justify;">
Pour ce faire, on parcourt lâ€™Ã©chantillon de lâ€™onde, puis Ã  partir de lâ€™amplitude [i], on Ã©tabli une moyenne des valeurs Â« hautes Â» ([i], [i+2], [i+7], [i+9]), puis on vÃ©rifie que toutes les autres valeurs jusquâ€™Ã  [i+15] sont infÃ©rieures aux valeurs hautes et suivent les bonnes variations dâ€™amplitudes. </p>
<p style="text-align:justify;">
DÃ¨s que lâ€™on identifie un prÃ©ambule, on stocke les 224 points suivants de lâ€™Ã©chantillon pour les convertir en binaire selon la mÃ©thode suivante :
Chaque paire de points successives et dâ€™amplitudes (A1, A2) dÃ©finit un unique bit b tel que si A1>A2 alors b = 1, sinon b=0.</p>
<p>Nous obtenons enfin les 112 bits.</p>
<p>DÃ¨s lors, nous sommes en mesure de vÃ©rifier lâ€™intÃ©gritÃ© du message Ã  lâ€™aide du CRC.</p>
<p>Ce dernier se reprÃ©sente sous la forme dâ€™un polynÃ´me :</p>
<code>
ğ‘ƒ(ğ‘¥)= ğ‘¥<sup>24</sup> + ğ‘¥<sup>23</sup> + ğ‘¥<sup>22</sup> + ğ‘¥<sup>21</sup> + ğ‘¥<sup>20</sup> + ğ‘¥<sup>19</sup> + ğ‘¥<sup>18</sup> + ğ‘¥<sup>17</sup> + ğ‘¥<sup>16</sup> + ğ‘¥<sup>15</sup> + ğ‘¥<sup>14</sup> + ğ‘¥<sup>13</sup> + ğ‘¥<sup>12</sup> + ğ‘¥<sup>10</sup> + ğ‘¥<sup>3</sup> + 1
</code>
<p style="text-align:justify;">Le message binaire est alors transmis au serveur Ã  lâ€™aide de la bibliothÃ¨que de messagerie asynchrone zero-mq.</p><div style="break-before: page; page-break-before: always;"></div><h1 id="infrastructure"><a class="header" href="#infrastructure">Infrastructure</a></h1>
<p style="text-align:justify;">
Comme prÃ©sentÃ© prÃ©cÃ©demment, l'architecture mise en place implique que le code de *SOURCE* soit installÃ© sur une station, en l'occurence un raspberry, qui soit lui mÃªme connectÃ© Ã  une anntenne.</p>
<p style="text-align:justify;">
Nous l'avons mis en pratique, en installant une antenne spÃ©cialisÃ© pour l'ADS-B sur le toit d'une maison situÃ©e prÃ¨s de Castres dans le Tarn. Les conditions d'installation font qu'elle possÃ¨de une meilleure rÃ©ception vers l'Ouest (en thÃ©orie).</p>
<p style="text-align: center;">
<img  typeof="foaf:Image" src="source/../images/antenne_irl.jpg"  alt="" title="antenne">  
</p>
<p style="text-align:justify;">
Cette antenne est alors connectÃ©e Ã  un filtre 1090MHz (1), puis au dongle RTL-SDR (2) qui s'assure de l'Ã©chantillonage. La connexion Ã©thernet permet de transmettre au serveur situÃ© Ã  Evry les messages binaires reÃ§us.</p>
<p style="text-align: center;">
<img  typeof="foaf:Image" src="source/../images/source.png"  alt="" title="raspberry">  
</p>
<h1 id="performance-de-lantenne"><a class="header" href="#performance-de-lantenne">Performance de l'antenne</a></h1>
<p style="text-align:justify;">
On observe une trÃ¨s bonne performance de l'antenne, assurant une bonne rÃ©ception dans les 300km au sud, voir 500km</p>
<p style="text-align: center;">
<img  typeof="foaf:Image" src="source/../images/diagramme.png"  alt="" title="reception">  
</p><div style="break-before: page; page-break-before: always;"></div><h1 id="rustracker-1"><a class="header" href="#rustracker-1">Rustracker</a></h1>
<p style="text-align:justify;">Le serveur est chargÃ© du traitement des messages binaires qui sont reÃ§us par une ou plusieurs sources. </p>
<p style="text-align:justify;">Lorsque lâ€™on reÃ§oit un squitter, on commence par le dÃ©couper et le stocker sous forme de struct squitter, qui dispose de mÃ©thodes permettant dâ€™en rÃ©cupÃ©rer les diffÃ©rentes sections.</p>
<p style="text-align:justify;">Ã€ partir de son code OACI, on va associer le squitter Ã  un nouvel objet avion (la struct plane), qui a pour attribut lâ€™ensemble des informations utiles associÃ©es Ã  ce dernier. Chaque avion sera ensuite stockÃ© dans une hashmap ayant pour clef son code OACI. Associer un nouveau squitter reÃ§u d'un aÃ©ronef dÃ©jÃ  existant dans notre structure de donnÃ©es sera alors plus efficace.</p>
<p style="text-align:justify;">Une fois le squitter liÃ© Ã  lâ€™avion, on en extrait les informations. En lâ€™occurrence nous traitons 3 types de donnÃ©es : altitude, vitesse, et numÃ©ro de vol. Nous allons dÃ©tailler sÃ©parÃ©ment leurs analyses dans la section suivante.</p>
<h1 id="opÃ©rationabilitÃ©"><a class="header" href="#opÃ©rationabilitÃ©">OpÃ©rationabilitÃ©</a></h1>
<p style="text-align:justify;">Maintenant que nous avons une structure de donnÃ©es avec toutes les informations exploitables, il faut pouvoir la rendre opÃ©rationnelle, câ€™est-Ã -dire que lâ€™on soit en mesure de crÃ©er une carte interactive des avions. Nous avons fait le choix que le programme gÃ©nÃ¨re un geojson qui pourra Ãªtre lu de maniÃ¨re passive par notre interface graphique.</p>
<p>Pour ce faire, on fait face Ã  plusieurs enjeux :</p>
<ul>
<li>
<p>Pouvoir gÃ©nÃ©rer ce geojson Ã  intervalle de temps rÃ©gulier, sans interrompre le processus de rÃ©ception
des squitters.</p>
</li>
<li>
<p>ÃŠtre capable de retirer les avions qui sont sortis de notre champ de rÃ©ception depuis un certain
temps.</p>
</li>
</ul>
<p style="text-align:justify;">Pour ces deux problÃ¨mes, nous avons dÃ©cidÃ© dâ€™utiliser la programmation asynchrone. Deux threads vont Ãªtre capables de communiquer avec le thread principal de rÃ©ception des messages Ã  travers des channels.</p>
<p style="text-align:justify;">Le premier thread est chargÃ© de gÃ©rer la durÃ©e de vie des avions. Il envoi un signal Ã  notre thread principal toute les 30 secondes, dÃ¨s que ce dernier reÃ§oit ce signal, il va parcourir la hashmap contenant chaque avion, et mesurer depuis combien de temps il nâ€™a pas reÃ§u de nouveaux messages. Si ce temps dÃ©passe 30 secondes, alors on considÃ¨re que lâ€™avion est sorti de notre champ de rÃ©ception, et est donc retirÃ© de notre mÃ©moire.</p>
<p style="text-align:justify;">Le second thread lui gÃ©nÃ¨re le geojson. Un package de Rust spÃ©cialement crÃ©Ã© pour les geojson propose une struct dans laquelle on stocke nos avions (avec moins dâ€™information que notre struct plane dÃ©taillÃ©e plus tÃ´t, on ne mettra dans le geojson que les donnÃ©es utiles Ã  lâ€™interface graphique) et qui grÃ¢ce Ã  une mÃ©thode de conversion en string de cette struct, nous permet dâ€™Ã©diter le contenu de notre fichier plane.geojson.</p><div style="break-before: page; page-break-before: always;"></div><h1 id="compact-position-reporting-cpr-"><a class="header" href="#compact-position-reporting-cpr-">Compact Position Reporting (CPR) :</a></h1>
<p style="text-align:justify;">La contrainte des 56 bits de donnÃ©es dans le cadre de la position peut Ãªtre problÃ©matique pour obtenir une prÃ©cision suffisante. En effet, le rÃ´le numÃ©ro 1 du contrÃ´le aÃ©rien est dâ€™assurer la sÃ©curitÃ© des avions par une bonne sÃ©paration de ceux-ci. Or pour ce faire, il faut avoir lâ€™altitude de lâ€™avion, sa latitude, et sa longitude.</p>
<p style="text-align:justify;">Pour le codage de la latitude/longitude, en pratique une prÃ©cision suffisante (environs 5 mÃ¨tres prÃ¨s) est atteinte en 45 bits, or seul 35 sont utilisÃ©s. Et cela grÃ¢ce Ã  lâ€™algorithme de compact position reporting.</p>
<p style="text-align:justify;">Cet algorithme repose sur le dÃ©coupage du globe en zone longitudinale et latitudinal. On procÃ¨de Ã  deux dÃ©coupages lÃ©gÃ¨rement diffÃ©rents, ce qui donne deux grilles que lâ€™on nomme paire et impaire. Ainsi, au lieu dâ€™encoder la position sur un seul message, seule la position Ã  lâ€™intÃ©rieur dâ€™une case dâ€™une grille est codÃ©e. On transmet alors cette position Â« interne Â» Ã  la grille sur un message qui indique sa paritÃ©, puis en couplant les messages de positions pair et impair, nous parvenons Ã  identifier la position rÃ©elle de lâ€™avion.</p>
<p style="text-align:justify;">Un exemple de lâ€™idÃ©e quâ€™utilise lâ€™algorithme CPR peut se faire Ã  lâ€™aide de surface Â« simple Â» de 16x16, on divise cette surface par une grille de 5x5, notre grille paire, et une grille de 4x4, notre grille impaire.</p>
<p style="text-align:justify;">La position que lâ€™on souhaite obtenir est de (x=7 ; y=9). Cette position se trouve aux coordonnÃ©es (x = 2 ; y=4) dâ€™une case de la grille paire et dans (x= 3 ; y = 1) de la grille impaire. On retrouve la position en superposant toutes les possibilitÃ©s des deux grilles, et en obtenant une unique correspondance entre les deux.</p>
<p style="text-align: center;">
<img  typeof="foaf:Image" src="rustracker/../images/cpr.png"  alt="" title="cpr">  
</p>
<p style="text-align:justify;">En pratique, lâ€™algorithme CPR commence par dÃ©coder dans cet ordre lâ€™index de la zone latitudinale, la latitude, puis lâ€™index de la zone longitudinale puis la longitude. En effet, on cherche la position dâ€™abord globale, câ€™est-Ã -dire identifier la Â« case Â» dans laquelle se situe lâ€™avion.</p>
<p style="text-align:justify;">Cette recherche qui sâ€™effectue grÃ¢ce Ã  un message pair et impair donne une position Â« globale Â».</p>
<p style="text-align:justify;">Ce premier dÃ©codage de position permet en effet de connaÃ®tre la zone dans laquelle lâ€™avion se situe. Puisque le dÃ©placement de lâ€™avion est continu, pour le dÃ©codage des positions suivantes, les index longitudinaux et latitudinaux peuvent Ãªtre directement dÃ©duis de la position prÃ©cÃ©dente. On utilisera alors quâ€™un seul message de paritÃ©s quelconque.</p>
<p style="text-align:justify;">Les messages de positions transmettent aussi lâ€™altitude qui se dÃ©code sans algorithme particuliÃ¨rement remarquable.</p>
<p style="text-align:justify;">
</p><div style="break-before: page; page-break-before: always;"></div><h1 id="gestion-des-erreurs-de-positions-"><a class="header" href="#gestion-des-erreurs-de-positions-">Gestion des erreurs de positions :</a></h1>
<p style="text-align:justify;">Lâ€™algorithme de CPR prÃ©sente un avantage certain. Toutefois, il peut comporter des erreurs. Celles-ci sont principalement dÃ»es au dÃ©codage des index des zones de latitude et longitude, et Ã  dâ€™autres calculs sensibles. Principalement lors de la transition de lâ€™avion entre deux zones distinctes.</p>
<p style="text-align:justify;">Comme prÃ©sentÃ© par la NASA (cf. bibliographie), ces erreurs sont dÃ»es Ã  lâ€™utilisations de nombres flottants. Leur code fournit des preuves en temps rÃ©el de leurs rÃ©sultats grÃ¢ce Ã  lâ€™ACSL.</p>
<p style="text-align:justify;">Cependant, nous devons trouver un moyen de traiter ces erreurs lorsquâ€™elles surviennent. </p>
<p style="text-align:justify;">Plusieurs solutions sont suggÃ©rÃ©es dans lâ€™ouvrage de Junzi Sun (cf. bibliographie), dont la cohÃ©rence de la position de lâ€™avion en fonction de la portÃ©e de lâ€™antenne. Cette solution nâ€™est pas envisageable pour nous car les rÃ©cepteurs communiquent de faÃ§on anonyme avec le serveur.</p>
<p style="text-align:justify;">En observant les positions aberrantes que nous obtenions, on a remarquÃ© une oscillation de la trajectoire. Nous avons donc imaginÃ© une autre solution, qui est un test de cohÃ©rence. </p>
<p style="text-align: center;">
<img  typeof="foaf:Image" src="rustracker/../images/erreur.png"  alt="" title="erreur">  
</p>
<p style="text-align:justify;">Comme prÃ©sentÃ© postÃ©rieurement, les messages de vitesses donnent une information : le Â« Track angle Â», qui est le cap suivi par lâ€™avion (entre 0Â° et 360Â°). Or ce cap peut aussi Ãªtre obtenu par une dÃ©duction Ã  partir des deux derniÃ¨res positions connues qui crÃ©ent un vecteur dont la direction est Ã©gale au cap (bien que plus imprÃ©cis).</p>
<p style="text-align:justify;">En comparant les deux rÃ©sultats obtenus sur les toutes premiÃ¨res positions dÃ©codÃ©es de lâ€™avion, nous pouvons dÃ©tecter ces oscillations qui sont impossibles avec un cap constant et donc Ã©liminer ces trajectoires problÃ©matiques. </p>
<h1 id="mise-en-pratique-"><a class="header" href="#mise-en-pratique-">Mise en pratique :</a></h1>
<p style="text-align:justify;">Cette comparaison de cap Ã©tait initialement effectuÃ©e sur tous les points de la trajectoire, cependant le calcul est lourd et a entraÃ®nÃ© un retard du serveur sur les messages reÃ§us. Nous avons donc fait le choix de tester seulement les premiÃ¨res positions de l'avion.</p><div style="break-before: page; page-break-before: always;"></div><h1 id="vitesse"><a class="header" href="#vitesse">Vitesse</a></h1>
<p>Les messages portant les informations de vitesses ont un type-code Ã©gal Ã  19.</p>
<p>Les messages de vitesse sont contituÃ©s de la maniÃ¨re suivante : </p>
<table><thead><tr><th></th><th>MSG</th><th>BITS</th></tr></thead><tbody>
<tr><td><strong>Type Code</strong></td><td>1-5</td><td>5</td></tr>
<tr><td><strong>Sub-Type</strong></td><td>6-8</td><td>3</td></tr>
<tr><td><strong>Intent change flag</strong></td><td>9</td><td>1</td></tr>
<tr><td><strong>IFR capability flag</strong></td><td>10</td><td>1</td></tr>
<tr><td><strong>Navigation uncertainty category for velocity</strong></td><td>11-13</td><td>3</td></tr>
<tr><td><strong>Sub-Type specific fields</strong></td><td>14-35</td><td>22</td></tr>
<tr><td><strong>Source bit for vertical rate</strong></td><td>36</td><td>1</td></tr>
<tr><td><strong>Sign bit for vertical rate</strong></td><td>37</td><td>1</td></tr>
<tr><td><strong>Vertical rate</strong></td><td>38-46</td><td>9</td></tr>
<tr><td><strong>Reserved</strong></td><td>47-48</td><td>2</td></tr>
<tr><td><strong>Sign bit for GNSS and Baro altitudes difference</strong></td><td>49</td><td>1</td></tr>
<tr><td><strong>Difference between GNSS and Baro altitudes</strong></td><td>50-56</td><td>7</td></tr>
</tbody></table>
<p>Dans le cadre de notre travail, tous ces champs ne sont pas utiles. On s'interresse particuliÃ¨rement aux champs concernant la vitesse, la vitesse verticale ainsi que l'angle de piste des avions.</p>
<p>Les diffÃ©rents sous-types (Sub-type) permettent de distinguer les types de vitesses enregistrÃ©s ainsi que les types des avions (subsonniques et supersonniques).</p>
<table><thead><tr><th><strong>Sub-Type</strong></th><th>Type vitesse</th><th>Type avion</th></tr></thead><tbody>
<tr><td><strong>1</strong></td><td>GS</td><td>Subsonnic</td></tr>
<tr><td><strong>2</strong></td><td>GS</td><td>Supersonnic</td></tr>
<tr><td><strong>3</strong></td><td>TAS or IAS</td><td>Subsonnic</td></tr>
<tr><td><strong>4</strong></td><td>TAS or IAS</td><td>Supersonnic</td></tr>
</tbody></table>
<p>On distingue plusieurs types de vitesses : </p>
<p style="text-align:justify;">
<ul>
  <li> <p style="text-align:justify;"> <b>Indicated Air Speed (IAS) </b> = vitesse indiquÃ©e, c'est la vitesse directement lue dans le cockpit de l'avion, elle est mesurÃ©e grÃ¢ce Ã  des capteurs de pression et varie donc en fonction de l'altitude (baisse lorsque l'altitude augmente); </p></li>
  <li> <p style="text-align:justify;"> <b>True Air Speed (TAS) </b>= c'est la vitesse rÃ©elle de l'avion relativement Ã  l'air qui l'entoure;</p> </li>
  <li><p style="text-align:justify;"> <b>Ground Speed (GS) </b> = vitesse au sol, il s'agit de la vitesse rÃ©elle corrigÃ©e qui tient compte des vents.</p>
</li>
</ul> 
</p>
<p style="text-align:justify;">
<p>Puisque qu'il n'y a actuellement plus d'avions supersonniques en circulation (retrait du concorde en 2003), les sous-types 2 et 4 n'ont pour l'instant pas d'utilitÃ©. </p></p>
<h2 id="dÃ©codage-vitesse"><a class="header" href="#dÃ©codage-vitesse">DÃ©codage vitesse</a></h2>
<h3 id="sous-type-1"><a class="header" href="#sous-type-1">Sous-type 1</a></h3>
<p>La partie du message de vitesse utile pour le dÃ©codage de la vitesse sont les bits 14 Ã  35 dÃ©composÃ©s de la maniÃ¨re suivante : </p>
<table><thead><tr><th></th><th></th><th><strong>MSG</strong></th><th><strong>BITS</strong></th></tr></thead><tbody>
<tr><td><strong>Direction pour la composante de vitesse E-O</strong></td><td>Dew</td><td>14</td><td>1</td></tr>
<tr><td><strong>Composante de vitesse Est-Ouest</strong></td><td>Vew</td><td>15-24</td><td>10</td></tr>
<tr><td><strong>Direction pour la composante de vitesse N-S</strong></td><td>Dns</td><td>25</td><td>1</td></tr>
<tr><td><strong>Composante de vitesse Nord-Sud</strong></td><td>Vns</td><td>26-35</td><td>10</td></tr>
</tbody></table>
<p style="text-align:justify;">
<p>On calcule la vitesse Ã  partir des composantes Vew et Vns ainsi que des directions Dew et Dns.</p>
<p>On calcule Ã©galement le track angle (angle de piste) qui permet d'orienter les avions sur la carte Ã  l'aide de ces valeurs.</p>
</p>
<h3 id="sous-type-3"><a class="header" href="#sous-type-3">Sous-type 3</a></h3>
<p style="text-align:justify;">
<p>Les messages de sous-type 3 sont Ã©mis lorsque la vitesse au sol de l'avion n'est pas connue (par exemple quand le positionnement par satellite n'est pas disponible). Dans ce cas, la vitesse et le track angle sont directement encodÃ©s dans le message de la maniÃ¨re suivante : </p>
</p>
<table><thead><tr><th></th><th></th><th><strong>MSG</strong></th><th><strong>BITS</strong></th></tr></thead><tbody>
<tr><td><strong>Bit de status pour le cap magnÃ©tique</strong></td><td>SH</td><td>14</td><td>1</td></tr>
<tr><td><strong>Cap magnÃ©tique</strong></td><td>HDG</td><td>15-24</td><td>10</td></tr>
<tr><td><strong>Type de vitesse (IA or TAS)</strong></td><td>T</td><td>25</td><td>1</td></tr>
<tr><td><strong>Vitesse</strong></td><td>AS</td><td>26-35</td><td>10</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="callsign"><a class="header" href="#callsign">Callsign</a></h1>
<p style="text-align:justify;">Le callsign permet d'identifier un avion en vol. Ã€ la diffÃ©rence de l'icao, le callsign n'est pas unique, plusieurs avions effectuant le mÃªme trajet Ã  des moments diffÃ©rents auront le mÃªme callsign. La donnÃ©e du callsign est contenue dans les messages dont le type-code est compris entre 1 et 4. Un tel message est structurÃ© de la maniÃ¨re suivante : </p>
<table><thead><tr><th><strong>Data</strong></th><th><strong>TC</strong></th><th><strong>CA</strong></th><th><strong>C1</strong></th><th><strong>C2</strong></th><th><strong>C3</strong></th><th><strong>C4</strong></th><th><strong>C5</strong></th><th><strong>C6</strong></th><th><strong>C7</strong></th><th><strong>C8</strong></th></tr></thead><tbody>
<tr><td><strong>BITS</strong></td><td>5</td><td>3</td><td>6</td><td>6</td><td>6</td><td>6</td><td>6</td><td>6</td><td>6</td><td>6</td></tr>
</tbody></table>
<p>On retrouve le type code (TC) contenu dans les 5 premiers bits suivi de la catÃ©gorie de l'engin (CA). Ensuite, chaque bloc de 6 bits permet de dÃ©terminer un caractÃ¨re du callsign.</p>
<p>Pour trouver le callsign il suffit de convertir chaque bloc de 6 bits en dÃ©cimal, les 8 nombres obtenus sont alors les indices des caractÃ¨res du callsign dans l'alphabet suivant : </p>
<blockquote>
<p>#ABCDEFGHIJKLMNOPQRSTUVWXYZ#####################0123456789######</p>
</blockquote>
<p>Par exemple, le callsign associÃ© au message suivant est <strong>KLM1023</strong> : </p>
<table><thead><tr><th><strong>MSG</strong></th><th><strong>00100</strong></th><th><strong>000</strong></th><th><strong>001011</strong></th><th><strong>001100</strong></th><th><strong>001101</strong></th><th><strong>110001</strong></th><th><strong>110000</strong></th><th><strong>110010</strong></th><th><strong>110011</strong></th><th><strong>100000</strong></th></tr></thead><tbody>
<tr><td><strong>DATA</strong></td><td>TC</td><td>CA</td><td>11</td><td>12</td><td>13</td><td>49</td><td>48</td><td>50</td><td>51</td><td>32</td></tr>
<tr><td><strong>DATA</strong></td><td>4</td><td>0</td><td>K</td><td>L</td><td>M</td><td>1</td><td>0</td><td>2</td><td>3</td><td>-</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trackui"><a class="header" href="#trackui">Trackui</a></h1>
<p style="text-align:justify;">Lâ€™interface graphique est codÃ©e en JavaScript. On utilise Leaflet qui est un package permettant de gÃ©nÃ©rer une carte. Cette carte affiche en temps rÃ©el les avions dont la position est partagÃ©e.</p>
<p style="text-align:justify;">Cependant comme ce nâ€™est pas toujours le cas (selon le type de transpondeur de lâ€™avion), et afin de prÃ©senter les informations supplÃ©mentaires tel que le numÃ©ro de vol, lâ€™altitude et la vitesse, on a fait le choix dâ€™ajouter un tableau contenant la liste des avions.</p>
<p style="text-align:justify;">De plus, ce tableau dispose de code OACI Â« cliquable Â» pour les avions dont la position est visible sur la carte. Lorsque lâ€™on clique sur un bouton, la carte se recentre alors sur lâ€™avion sÃ©lectionnÃ© et affiche son icone et sa trajectoire dans une couleur diffÃ©rente afin de le mettre en valeur.</p>
<p style="text-align:justify;">Enfin, la collecte des informations se fait en rÃ©cupÃ©rant les informations du geojson gÃ©nÃ©rÃ© par Rustracker toutes les 1,5 secondes. Le geojson est une FeatureCollection qui regroupe plusieurs Features qui sont nos avions. Ces Features ont pour ID le code OACI, et sont des LineString, câ€™est-Ã -dire que le champ geometry contient lâ€™ensemble des points qui composent la trajectoire, puis dispose en attribut du reste des informations de lâ€™avion.</p>
<p style="text-align:justify;">En itÃ©rant sur toutes les Feature, on ajoute pour chacune un calque Ã  la carte qui affiche la trajectoire, et lâ€™icone que lâ€™on oriente grÃ¢ce au Â« track angle Â» (la route suivie par lâ€™avion). Chacun de ces calques sont dans un mÃªme groupe de calque.</p>
<p style="text-align:justify;">
Ã€ chaque nouvelle rÃ©ception des donnÃ©es du geojson, on vide alors ce groupe de calque afin de le remplir de nouveau avec les informations actualisÃ©es.</p><div style="break-before: page; page-break-before: always;"></div><h1 id="storyline"><a class="header" href="#storyline">Storyline</a></h1>
<p>Le rÃ©tro planning original Ã©tait:</p>
<p><img src="images/retroplan.png" alt="Retro Planning" /></p>
<p>Mais des difficultÃ©s son apparu pendant le projet, ce qui nous a forcÃ© Ã  le modifier lÃ©gÃ¨rement.</p>
<hr />
<h3 id="rÃ©union-du-270122"><a class="header" href="#rÃ©union-du-270122">RÃ©union du 27/01/22</a></h3>
<p>CrÃ©ation du repertoire Git (licence GNU GPL v3).
Discussion sur nos objectifs concernant le projet, livrable minimal, livrable amÃ©liorÃ©.
Langage : RUST (formation en cours) plus compliquÃ© Ã  prendre en main que Java/Python mais plus optimisÃ© pour notre projet.</p>
<p><strong>Discussion sur la structure :</strong></p>
<p>--&gt; Classe radar :</p>
<ul>
<li>Qui hÃ©rite de thread</li>
<li>S'Ã©xÃ©cute Ã  l'infini</li>
<li>ReÃ§oit des essages en permanence et crÃ©Ã©e un objet avion dÃ¨s qu'il est dÃ©tectÃ©</li>
<li>Extrait le message en cherchant le prÃ©ambule classique de l'ADS-B</li>
</ul>
<p>--&gt; Classe Avion :</p>
<ul>
<li>Message en binaire</li>
<li>Data : 56 bits, soit la vitesse, soit le numÃ©ro de vol, soit les coordonnÃ©es </li>
<li>Traduit les donnÃ©es </li>
<li>CrÃ©e une carte toutes les X secondes</li>
</ul>
<hr />
<h3 id="rÃ©union-du-100222"><a class="header" href="#rÃ©union-du-100222">RÃ©union du 10/02/22</a></h3>
<p>Discussion autour du projet, notamment autour de la structure du projet ainsi que des grandes Ã©tapes, et autour du rÃ©troplanning que nous allons prÃ©senter dans le premier livrable. </p>
<p>DÃ©but du code de fonctions simples pour prendre en main RUST : </p>
<ul>
<li>Une fonction qui dÃ©coupe un message binaire de 56 bits afin de rÃ©cupÃ©rer les sections de bits correspondant aux informations sur le vol</li>
<li>Une fonction qui gÃ¨re la base de donnÃ©es contenant les informations relatives aux avions (modÃ¨le, moteur, etc)</li>
</ul>
<hr />
<h3 id="rÃ©union-du-170222"><a class="header" href="#rÃ©union-du-170222">RÃ©union du 17/02/22</a></h3>
<p>Discussion sur le livrable 1 Ã  rendre dans la semaine.
Ã‰criture de la prÃ©sentation du projet avec les objectifs (livrable minimal et idÃ©al), diagramme de sÃ©quence et rÃ©troplanning.<br />
La fonction callsign() qui dÃ©coupe et traduit le message de 56 bits.
Le groupe continue son apprentissage du RUST.</p>
<hr />
<h3 id="rÃ©union-du-240222"><a class="header" href="#rÃ©union-du-240222">RÃ©union du 24/02/22</a></h3>
<ul>
<li>Le premier livrable a Ã©tÃ© tÃ©lÃ©versÃ© (18/02) sur moodle.</li>
<li>Code des fonctions permettant d'extraire la position (latitude, longitude) du message.</li>
<li>Discussion pour l'interface graphique : nous allons commencer Ã  regarder imgui.</li>
</ul>
<hr />
<h3 id="rÃ©union-du-030322-point-rencontre"><a class="header" href="#rÃ©union-du-030322-point-rencontre">RÃ©union du 03/03/22 (point rencontre)</a></h3>
<ul>
<li>PrÃ©fÃ©rable de scinder le projet en deux sous-projets : 'backend' et 'frontend'. CrÃ©ation du second rÃ©pertoire <a href="https://github.com/GuilhemHnr/trackui">trackui</a> dans ce but prÃ©cis.</li>
<li>Discussion autout de l'interface graphique : on part sur imgui avec l'utilisation de ZeroMQ pour sÃ©parer le 'backend' et le 'frontend'.</li>
<li>RÃ©ception des messages : voir le framword rtlsdr_mt (pas actualisÃ©) sinon se tourner vers soapysdr.</li>
<li>Choix d'utiliser des array de boolÃ©ens pour reprÃ©senter les messages binaires plutÃ´t que des string pour gain de mÃ©moire.</li>
<li>Discussion autour du livrable 2 Ã  rendre la semaine d'aprÃ¨s.</li>
</ul>
<hr />
<h3 id="rÃ©union-du-160322-point-rencontre"><a class="header" href="#rÃ©union-du-160322-point-rencontre">RÃ©union du 16/03/22 (point rencontre)</a></h3>
<ul>
<li>Discussion autour des bases de donnÃ©es : se tourner vers SQLLite3 plutÃ´t.</li>
<li>Clarifier le code aux endroits oÃ¹ il devient un peu lourd et peu intuitif.</li>
<li>Regarder des librairies de logging pour Ã©ventuellement gÃ©nÃ©rer des logs.</li>
<li>ProblÃ¨mes rÃ©glÃ© pour imgui.</li>
<li>Discussion autour de l'interface graphique, il faut choisir entre :
<ul>
<li>imgui qui fonctionnerait avec ZeroMQ : il faut chercher comment gÃ©nÃ©rer une carte (openstreetmap), les tiles</li>
<li>interface web avec HTML/CSS, Javascript : utilisation de leaflet pour gÃ©nÃ©rer facilement une carte, utiliser des websockets pour communiquer entre back/front</li>
</ul>
</li>
</ul>
<hr />
<h3 id="rÃ©union-du-29032022-rapide-"><a class="header" href="#rÃ©union-du-29032022-rapide-">RÃ©union du 29/03/2022 (rapide) :</a></h3>
<ul>
<li>Choix d'utiliser Yew et leaflet-rs pour l'interface graphique</li>
<li>Prise en main de Yew et leaflet-rs, mais beaucoup de difficultÃ©s sont rencontrÃ©es avec l'utilisation de cette bibliothÃ¨que.</li>
<li>ZeroMQ : grÃ¢ce Ã  l'exemple fournit par  RÃ©my GrÃ¼nblatt un code minimal d'emission/reception serveur/client a Ã©tÃ© mis au point et fonctionne correctement (pour l'instant en local).</li>
</ul>
<h4 id="objectifs-pour-la-semaine-prochaine-"><a class="header" href="#objectifs-pour-la-semaine-prochaine-">Objectifs pour la semaine prochaine :</a></h4>
<ul>
<li>RÃ©ussir Ã  afficher une icone d'avion et Ã  gÃ©rer sa position sur la carte</li>
<li>GÃ©rer proprement la rÃ©ception des messages cÃ´tÃ© client</li>
<li>GÃ©rer l'affichage des donnÃ©es cÃ´tÃ© client</li>
</ul>
<hr />
<h3 id="rÃ©union-du-14042022-point-rencontre-"><a class="header" href="#rÃ©union-du-14042022-point-rencontre-">RÃ©union du 14/04/2022 (point rencontre) :</a></h3>
<ul>
<li>Discussion autour de l'interface graphique, notamment de Yew qui nous pose plusieurs problÃ¨mes : on laisse tomber le rust pour le web et on part sur du web pur / javascript.</li>
<li>Discussion autour de l'organisation du projet : il faut que chacun s'organise pour participer au projet (frontend, backend, connexion Ã  internet, rapport, slides soutenance etc...).</li>
<li>Discussion autour de la forme du rapport : possibilitÃ© d'utiliser des fichiers markdown puis de les convertir avec pandoc.</li>
<li>La redistribution des rÃ´les :<br />
--&gt; Guilhem : termine le backend cÃ´tÃ© web<br />
--&gt; Romain : s'occupe du cÃ´tÃ© serveur, mise en place d'une vm pour pouvoir faire passer les sockets par internet et utiliser plusieurs antennes<br />
--&gt; Artur : s'occupe du frontend, apparence de l'interface web<br />
--&gt; Bastian : rÃ©dige le rapport sous la forme de rustbook</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h1>
<p>Les grands objectifs du projet sont remplis et notre livrable final est opÃ©rationnel. Ce projet aura Ã©tÃ© trÃ¨s enrichissant dans la mesure oÃ¹ nous avons dÃ©couvert le langage de programmation RUST et nous avons eu a traiter diverses problÃ©matiques (traitement du signal, interface web, serveur sur machine virtuelle, programmation asynchrone, communications tcp, etc).</p>
<h3 id="contributeurs"><a class="header" href="#contributeurs">Contributeurs</a></h3>
<p>Les quatre Ã©tudiants de TÃ©lÃ©com SudParis ayant contribuÃ©s au projet sont : </p>
<ul>
<li><a href="https://github.com/Witaek">Romain AmÃ©dÃ©e</a></li>
<li><a href="https://github.com/ArthurChauve">Arthur Chauve</a></li>
<li><a href="https://github.com/GuilhemHnr">Guilhem HonorÃ©</a></li>
<li><a href="https://github.com/blaaass">Bastian Larvor</a></li>
</ul>
<p>Un grand merci Ã  <a href="https://github.com/rgrunbla">RÃ©my GrÃ¼nblatt</a> pour ses conseils et son aide.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bibliographie"><a class="header" href="#bibliographie">Bibliographie</a></h1>
<h1 id="the-1090mhz-riddle"><a class="header" href="#the-1090mhz-riddle">The 1090Mhz Riddle</a></h1>
<code>
@book{sun1090mhz,
    author = {Sun, Junzi}, 
    title = {The 1090 Megahertz Riddle: A Guide to Decoding Mode S and ADS-B Signals},
    publisher = {TU Delft OPEN Publishing},
    year = 2021,
    edition = 2,
    isbn = {978-94-6366-402-8},
    doi = {10.34641/mg.11}
}
</code>
<h1 id="explication-de-la-nasa-sur-lalgorithme-cpr"><a class="header" href="#explication-de-la-nasa-sur-lalgorithme-cpr">Explication de la NASA sur l'algorithme CPR</a></h1>
<p><a href="https://github.com/nasa/cpr">GitHub NASA</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
