<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content=" The Trackbook describes the structures and goals of the RusTracker project">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded "><a href="prerequis.html"><strong aria-hidden="true">1.</strong> Prérequis</a></li><li class="chapter-item expanded "><a href="architecture.html"><strong aria-hidden="true">2.</strong> Architecture</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Guide d'utilisation</li><li class="chapter-item expanded "><a href="guide.html"><strong aria-hidden="true">3.</strong> Guide</a></li><li class="chapter-item expanded affix "><li class="part-title">Contexte</li><li class="chapter-item expanded "><a href="contexte.html"><strong aria-hidden="true">4.</strong> ADS-B</a></li><li class="chapter-item expanded affix "><li class="part-title">Source</li><li class="chapter-item expanded "><a href="source/reception.html"><strong aria-hidden="true">5.</strong> Source</a></li><li class="chapter-item expanded "><a href="source/infrastructure.html"><strong aria-hidden="true">6.</strong> Infrastructure</a></li><li class="chapter-item expanded affix "><li class="part-title">Rustracker</li><li class="chapter-item expanded "><a href="rustracker/rustracker.html"><strong aria-hidden="true">7.</strong> Rustracker</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rustracker/position.html"><strong aria-hidden="true">7.1.</strong> Position</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rustracker/erreurs.html"><strong aria-hidden="true">7.1.1.</strong> Erreurs</a></li></ol></li><li class="chapter-item expanded "><a href="rustracker/vitesse.html"><strong aria-hidden="true">7.2.</strong> Vitesse</a></li><li class="chapter-item expanded "><a href="rustracker/callsign.html"><strong aria-hidden="true">7.3.</strong> Callsign</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Trackui</li><li class="chapter-item expanded "><a href="trackui/trackui.html"><strong aria-hidden="true">8.</strong> Trackui</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="story.html">Project Storyline</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="conclusion.html">Conclusion</a></li><li class="chapter-item expanded affix "><a href="bibliographie.html">Bibliographie</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p style="text-align:justify;">L’ADS-B (Automatic Dependent Surveillance-Broadcast) est un système de contrôle du trafic aérien. Un avion utilisant l’ADS-B détermine sa position par un système de positionnement satellite et renvoie cette dernière (ainsi que d’autres informations sur le vol, altitude, vitesse, modèle de l’avion, etc) dans toutes les directions aux autres appareils disposant de l’ADS-B. Ces messages sont détectables, puis démodulables, par toute personne à l’aide d’une clef TNT (tuner RTL2832U, 15€), utilisée en SDR (Software Defined Radio), qui permet de définir les paramètres de réception (comme par exemple la fréquence), depuis l’ordinateur. L’objectif du projet est d’utiliser ces messages envoyés par les avions, et de proposer une interface graphique à l’utilisateur. Sur cette interface, on souhaite observer en temps réel l’ensemble des avions à portée de notre antenne et leur trajectoire, ainsi que les informations sur le vol (altitude, vitesse, moteur, ...).</p>
<h3 id="description-du-livrable-minimal-"><a class="header" href="#description-du-livrable-minimal-">Description du livrable minimal :</a></h3>
<ul>
<li>Intercepter, démoduler, interpréter des signaux ADS-B envoyés par plusieurs avions</li>
<li>En extraire des informations sur la position, vitesse, modèle,...</li>
<li>Utiliser ces données pour générer en temps réel une carte sur laquelle figurent les avions</li>
<li>Possibilité d’obtenir les informations concernant le vol des avions sélectionnés</li>
</ul>
<br/>
<p style="text-align: center;">
<img  typeof="foaf:Image" src="images/exemple.png"  width="350" height="350" alt="" title="Foto: Edis Škulj/fkmladost.ba">  
</p>
<p style="text-align: center;">
    <b> Exemple de carte recherchée (FlightRadar24) </b>
</p>
<h3 id="description-brève-"><a class="header" href="#description-brève-">Description brève :</a></h3>
<p>Ce projet est décomposé en trois parties communicantes les unes avec les autres : Source, Rustracker et TrackUI.</p>
<p style="text-align:justify;">
<ul>
  <li> <p style="text-align:justify;"> <b>Source</b> : c'est le programme chargé d'intercepter les signaux ADS-B émis par les avions à 1090MHz. Ensuite il les démodule (réception sous forme de I&Qs), les convertis en binaire et les envoi, grâce au protocole TCP, à Rustracker. </p></li>
  <li> <p style="text-align:justify;"> <b>Rustracker</b>: c'est le programme principal, stocké sur une machine virtuelle, qui récupère les signaux sous forme binaire émis par Source, les interprète afin d'en extraire les informations sur le vol des avions (position, vitesse, altitude, numéro de vol, etc). Il écrit toutes ces informations dans un fichier geojson qui sera lu par Trackui. </p> </li>
  <li><p style="text-align:justify;"> <b>Trackui</b>: il s'agit de l'interface graphique de notre travail, sous forme de page web, herbergée par un serveur nginx sur la machine virtuelle évoquée plus tôt. Elle consulte à intervalles de temps réguliers le fichier geojson mis à disposition par Rustracker et affiche les avions en conséquences sur la carte, les autres données concernant les avions sont regroupées dans un tableau à côté de la carte.</p>
</li>
</ul> 
</p><div style="break-before: page; page-break-before: always;"></div><h1 id="prérequis"><a class="header" href="#prérequis">Prérequis</a></h1>
<h2 id="rust"><a class="header" href="#rust">Rust</a></h2>
<p>Afin de faire fonctionner nos différents programmes (Source &amp; Rustracker), il est nécessaire d'installer le gestionnaire de paquet rust &quot;Cargo&quot; ainsi que le gestionnaire des chaînes d'outils &quot;rustup&quot;.</p>
<pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<br/>
<hr />
<h2 id="source"><a class="header" href="#source">Source</a></h2>
<p style="text-align:justify;">Afin de faire fonctionner Source,  il est nécessaire de configurer les drivers pour utiliser les dongles RTL-SDR correctement. On propose ici un guide afin d'effectuer les installations nécessaires au bon fonctionnement de Source.</p>
<h4 id="blacklist-des-pilotes"><a class="header" href="#blacklist-des-pilotes">Blacklist des pilotes</a></h4>
<p>Commençons par connecter le dongle TNT à l'ordinateur.</p>
<p>--&gt; La commande <code>dsemg</code> permet de vérifier que le dongle est bien connecté.</p>
<p>Nous allons maintenant blacklister le pilote permettant de regarder la TNT avec le dongle afin qu'il n'interfère pas dans le bon fonctionnement de notre programme.</p>
<pre><code>~ $ cd /etc/modprobe.d
/etc/modprobe.d $ sudo nano rtlsdr.conf
</code></pre>
<p>Rajoutons la ligne suivante dans le fichier rtlsdr.conf :</p>
<blockquote>
<p>blacklist dvb_usb_rtl28xxu</p>
</blockquote>
<p>Sauvegardons ensuite rtlsdr.conf.</p>
<p>--&gt; La commande <code>lsmod</code> permet de vérifier si le pilote est chargé</p>
<p>Enfin, supprimons le pilote déjà chargé.</p>
<pre><code>~ $ blacklist dvb_usb_rtl28xxu
</code></pre>
<h4 id="installation-des-pilotes"><a class="header" href="#installation-des-pilotes">Installation des pilotes</a></h4>
<p>Commençons par installer la librairie nécessaire à l'utilisation de SoapySDR, le crate que nous utilisons afin d'utiliser les dongles rtlsdr avec notre code RUST.</p>
<pre><code>sudo apt install libsoapysdr-dev libclang-dev llvm-dev pkg-config
</code></pre>
<p>On installe ensuite le pilote correspondant.</p>
<pre><code>sudo apt install soapysdr-module-rtlsdr
</code></pre>
<p>Enfin on installe le plugin Soapy pour RTL-SDR.</p>
<pre><code>git clone https://github.com/pothosware/SoapyRTLSDR.git
cd SoapyRTLSDR
mkdir build
cd build
cmake ..
make
sudo make install
</code></pre>
<br/>
<hr />
<h2 id="rustracker"><a class="header" href="#rustracker">Rustracker</a></h2>
<p>L'installation de certaines librairies est nécessaire au bon fonctionnement du programme Rustracker.</p>
<p>Installons d'abord une librairie permettant d'utiliser pkg-config, un programme de gestion des librairies.</p>
<pre><code>sudo apt install pkg-config
</code></pre>
<p>On installe ensuite la librairie ZeroMQ que l'on utilise pour les communications tcp entre Source et Rustracker.</p>
<pre><code>sudo apt install libzmq3-dev
</code></pre>
<p>Enfin, on installe deux packages nécessaires à la compilation.</p>
<pre><code>sudo apt install build-essential
sudo apt install cmake</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="format"><a class="header" href="#format">Format</a></h1>
<p>Notre projet est divisé en trois grandes parties :</p>
<ol>
<li>La réception des messages : Source</li>
<li>Leur traitement : Rustracker</li>
<li>Leur affichage dans une interface graphique web : Trackui</li>
</ol>
<p style="text-align:justify;"> 
L'intéraction entre ces trois parties est présentée dans le diagramme suivant qui facilitera la compréhension de l'architecture du projet que nous allons vous présenter. </p>
<p><img src="images/rustracker.png" alt="Diagramme rustracker" /></p>
<div style="break-before: page; page-break-before: always;"></div><p>La version complète et fonctionnelle du projet peut être observée sur le lien suivant <a href="http://rustracker.h.minet.net">RusTracker</a>.</p>
<p><img src="images/ui.png" alt="Interface" /></p>
<p>À gauche on trouve une carte où les avions sont affichés. Et à droite les vols avec toutes leurs informations sont listés dans un tableau.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contexte"><a class="header" href="#contexte">Contexte</a></h1>
<p style="text-align:justify;">
Le résultat final affiche sous forme de carte interactive des avions. Toutefois, l’information a suivi un long processus avant de pouvoir être présentée sous une forme compréhensible pour l’utilisateur.</p>
<p>Nous allons donc nous intéresser au voyage d’un message ADS-B.</p>
<p style="text-align:justify;"> 
Comme nous l’avons spécifié en introduction, l’<b>Automatic Dependent Surveillance-Broadcast</b> (ADS-B) est un mode de communication qui sert au contrôle aérien.
</p>
Les deux premières lettres de l’acronyme permettent de comprendre les enjeux du formatage et du mode de transmission des messages.
<p style="text-align:justify;"> 
<b>« Automatic »</b> signifie que les messages sont envoyés automatiquement, i.e. il n’est pas nécessaire de solliciter le transpondeur de l’avion pour obtenir une réponse (ce qui se fait dans d’autres méthodes de contrôle aérien). Cela impose donc egalement d’avoir un programme suffisamment performant pour soutenir les flows de messages.
</p>
<p style="text-align:justify;"> 
<b>« Dependent »</b> caractérise la provenance de ces informations. Tout est transmis par l’avion lui-même. Par exemple pour sa position, il la défini à partir de son système GPS embarqué avant de la transmettre. L’implication directe concerne le formatage des messages : il faut, dans un nombre de bits limités, transmettre suffisamment d’informations pour lier le message à l’avion et donner des informations suffisamment précises, et diverses (positions, vitesse, numéro de vol, …)
</p>
<h1 id="format-1"><a class="header" href="#format-1">Format</a></h1>
<p>Ainsi, le format d’un message ADS-B se présente sous la forme suivante :</p>
<p>Il comporte 112 bits, divisés en parties distinctes, chacune portant des informations spécifiques :</p>
<p style="text-align:justify;">
<ul>
  <li> <p style="text-align:justify;"> 
<p><b>[0 ; 4] : Downlink format :</b>  C’est le format de transmission, on ne s’intéresse ici qu’au 17, qui est le plus largement utilisé dans l’aviation civile. </p></li></p>
<li> <p style="text-align:justify;"> 
  <b>[5 ; 7] : Capability : </b> C’est un champ à utilisation technique que l’on traite en pratique dans le programme mais dont l’utilité pour un utilisateur lambda est faible, le résultat n’est donc pas présenté dans l’interface graphique (il permet d’obtenir notamment l’importance des tourbillons marginaux créés par l’avion, qui sont un phénomène dangereux pour un autre avion situé derrière, et est donc utilisé par les contrôleurs pour assurer une bonne séparation).</p> </li>
  <li><p style="text-align:justify;"> 
  <b>[8 ; 31] : adresse ICAO :</b>C’est l’élément le plus important du message, il s’agit d’un code hexadécimal et unique à l’avion tout au long de sa « vie ». Ce code étant unique et se trouvant dans tous les messages, c’est lui qui va permettre de lier des messages reçus indépendamment à l’avion émetteur.
</p>
</li>
 <li><p style="text-align:justify;"> 
 <b>[32 ; 87] : data : </b> Ces 56 bits sont le cœur du message, ce sont eux qui transportent l’information spécifique au vol à l’instant t. Les 5 premiers correspondent au « Type Code », qui nous indique le type de data reçu. Il peut s’agir de la vitesse, de la position, ou du numéro de vol, dont les formatages peuvent varier (nous le détaillerons plus tard).</p>
</li>
 <li><p style="text-align:justify;"> 
 <b>[88 ; 111] : CRC :</b>Ces derniers bits correspondent au contrôle de redondance cyclique (CRC). Ils sont calculés à l’émission de façon à ce qu’une opération logique sur l’ensemble des 112 bits donne un résultat spécifique, permettant ainsi de valider l’intégrité du message reçu. En effet, on reçoit de nombreux messages mais entre l’avion et notre antenne de réception, ils ont pu être dégradés d’une telle façon que l’information transportée est erronée. </p>
</li>
</ul> 
</p>
<p style="text-align:justify;"> 
Maintenant que l’on connaît ce qu’est un message ADS-B, nous allons pouvoir étudier tout son cheminement. Nous utiliserons par la suite le terme anglais de Squitter pour désigner un tel message.
</p><div style="break-before: page; page-break-before: always;"></div><h1 id="source-1"><a class="header" href="#source-1">Source</a></h1>
<p style="text-align:justify;">La réception des squitter se fait de façon indépendante de leur traitement dans un programme Rust nommé « Source ».
<p>Le principe est d’installer ce programme sur une station (dans notre cas un raspberry pi) dont le but est de capter le signal et de le transmettre au serveur.</p>
<p style="text-align:justify;">
Le squitter est d’abord émis par l’avion omnidirectionnellement sur la fréquence de 1090MHz, il voyage alors à travers l’atmosphère avant d’être réceptionné par notre antenne. L’onde de 1090Mhz est alors échantillonnée à l’aide d'un Dongle DVB-T pourvu d’une puce <b>RTL2832U</b>. Initiallement destiné à la réception de la TNT (≈20€), l’utilisation de drivers différents permet de le convertir en système SDR (Software Define Radio), dont on peut choisir la fréquence de réception.</p>
<p style="text-align:justify;">
Nous avons fait le choix d’utiliser Soapy SDR (disponible en package pour Rust), qui permet à l’aide de simple lignes de code, de se connecter au dongle et de choisir le taux d’échantillonnage, la fréquence de réception et le gain. </p>
<p style="text-align:justify;">
L’onde est modulée en quadrature (I&Q), le résultat est obtenu sous forme de complexe, que l’on démodule en calculant le module. À partir de là, on dispose de l’onde, toutefois il faut encore identifier les messages ADS-B situés dans l’échantillon. Ils sont échantillonnés à une fréquence : </p>
<p style="text-align: center;">
<code>
 fe = 2.10<sup>6</sup> Hz (soit Te = 500 ns)
 </code> </p>
 <p style="text-align:justify;">Sachant qu’il faut deux amplitudes pour coder un bit, la durée totale d’un message est de 112 microsecondes. Pour identifier le début du squitter on s’appuie sur la détection du préambule. Il s’agit d’un motif caractéristique (cf. image). Il existe plusieurs moyens de détecter un préambule (cf. bibliographie), nous avons utilisé sa détection logique. Le but de cette méthode est d’identifier par des opérations logiques (<, >) les successions d’amplitudes sur l’onde s’apparentant au motif (cf. figure préambule).</p>
<p style="text-align: center;">
<img  typeof="foaf:Image" src="source/../images/preambule.jpg"  alt="" title="preambule">  
</p>
<p style="text-align:justify;">
Pour ce faire, on parcourt l’échantillon de l’onde, puis à partir de l’amplitude [i], on établi une moyenne des valeurs « hautes » ([i], [i+2], [i+7], [i+9]), puis on vérifie que toutes les autres valeurs jusqu’à [i+15] sont inférieures aux valeurs hautes et suivent les bonnes variations d’amplitudes. </p>
<p style="text-align:justify;">
Dès que l’on identifie un préambule, on stocke les 224 points suivants de l’échantillon pour les convertir en binaire selon la méthode suivante :
Chaque paire de points successives et d’amplitudes (A1, A2) définit un unique bit b tel que si A1>A2 alors b = 1, sinon b=0.</p>
<p>Nous obtenons enfin les 112 bits.</p>
<p>Dès lors, nous sommes en mesure de vérifier l’intégrité du message à l’aide du CRC.</p>
<p>Ce dernier se représente sous la forme d’un polynôme :</p>
<code>
𝑃(𝑥)= 𝑥<sup>24</sup> + 𝑥<sup>23</sup> + 𝑥<sup>22</sup> + 𝑥<sup>21</sup> + 𝑥<sup>20</sup> + 𝑥<sup>19</sup> + 𝑥<sup>18</sup> + 𝑥<sup>17</sup> + 𝑥<sup>16</sup> + 𝑥<sup>15</sup> + 𝑥<sup>14</sup> + 𝑥<sup>13</sup> + 𝑥<sup>12</sup> + 𝑥<sup>10</sup> + 𝑥<sup>3</sup> + 1
</code>
<p style="text-align:justify;">Le message binaire est alors transmis au serveur à l’aide de la bibliothèque de messagerie asynchrone zero-mq.</p><div style="break-before: page; page-break-before: always;"></div><h1 id="infrastructure"><a class="header" href="#infrastructure">Infrastructure</a></h1>
<p style="text-align:justify;">
Comme présenté précédemment, l'architecture mise en place implique que le code de *SOURCE* soit installé sur une station, en l'occurence un raspberry, qui soit lui même connecté à une anntenne.</p>
<p style="text-align:justify;">
Nous l'avons mis en pratique, en installant une antenne spécialisé pour l'ADS-B sur le toit d'une maison située près de Castres dans le Tarn. Les conditions d'installation font qu'elle possède une meilleure réception vers l'Ouest (en théorie).</p>
<p style="text-align: center;">
<img  typeof="foaf:Image" src="source/../images/antenne_irl.jpg"  alt="" title="antenne">  
</p>
<p style="text-align:justify;">
Cette antenne est alors connectée à un filtre 1090MHz (1), puis au dongle RTL-SDR (2) qui s'assure de l'échantillonage. La connexion éthernet permet de transmettre au serveur situé à Evry les messages binaires reçus.</p>
<p style="text-align: center;">
<img  typeof="foaf:Image" src="source/../images/source.png"  alt="" title="raspberry">  
</p>
<h1 id="performance-de-lantenne"><a class="header" href="#performance-de-lantenne">Performance de l'antenne</a></h1>
<p style="text-align:justify;">
On observe une très bonne performance de l'antenne, assurant une bonne réception dans les 300km au sud, voir 500km</p>
<p style="text-align: center;">
<img  typeof="foaf:Image" src="source/../images/diagramme.png"  alt="" title="reception">  
</p><div style="break-before: page; page-break-before: always;"></div><h1 id="rustracker-1"><a class="header" href="#rustracker-1">Rustracker</a></h1>
<p style="text-align:justify;">Le serveur est chargé du traitement des messages binaires qui sont reçus par une ou plusieurs sources. </p>
<p style="text-align:justify;">Lorsque l’on reçoit un squitter, on commence par le découper et le stocker sous forme de struct squitter, qui dispose de méthodes permettant d’en récupérer les différentes sections.</p>
<p style="text-align:justify;">À partir de son code OACI, on va associer le squitter à un nouvel objet avion (la struct plane), qui a pour attribut l’ensemble des informations utiles associées à ce dernier. Chaque avion sera ensuite stocké dans une hashmap ayant pour clef son code OACI. Associer un nouveau squitter reçu d'un aéronef déjà existant dans notre structure de données sera alors plus efficace.</p>
<p style="text-align:justify;">Une fois le squitter lié à l’avion, on en extrait les informations. En l’occurrence nous traitons 3 types de données : altitude, vitesse, et numéro de vol. Nous allons détailler séparément leurs analyses dans la section suivante.</p>
<h1 id="opérationabilité"><a class="header" href="#opérationabilité">Opérationabilité</a></h1>
<p style="text-align:justify;">Maintenant que nous avons une structure de données avec toutes les informations exploitables, il faut pouvoir la rendre opérationnelle, c’est-à-dire que l’on soit en mesure de créer une carte interactive des avions. Nous avons fait le choix que le programme génère un geojson qui pourra être lu de manière passive par notre interface graphique.</p>
<p>Pour ce faire, on fait face à plusieurs enjeux :</p>
<ul>
<li>
<p>Pouvoir générer ce geojson à intervalle de temps régulier, sans interrompre le processus de réception
des squitters.</p>
</li>
<li>
<p>Être capable de retirer les avions qui sont sortis de notre champ de réception depuis un certain
temps.</p>
</li>
</ul>
<p style="text-align:justify;">Pour ces deux problèmes, nous avons décidé d’utiliser la programmation asynchrone. Deux threads vont être capables de communiquer avec le thread principal de réception des messages à travers des channels.</p>
<p style="text-align:justify;">Le premier thread est chargé de gérer la durée de vie des avions. Il envoi un signal à notre thread principal toute les 30 secondes, dès que ce dernier reçoit ce signal, il va parcourir la hashmap contenant chaque avion, et mesurer depuis combien de temps il n’a pas reçu de nouveaux messages. Si ce temps dépasse 30 secondes, alors on considère que l’avion est sorti de notre champ de réception, et est donc retiré de notre mémoire.</p>
<p style="text-align:justify;">Le second thread lui génère le geojson. Un package de Rust spécialement créé pour les geojson propose une struct dans laquelle on stocke nos avions (avec moins d’information que notre struct plane détaillée plus tôt, on ne mettra dans le geojson que les données utiles à l’interface graphique) et qui grâce à une méthode de conversion en string de cette struct, nous permet d’éditer le contenu de notre fichier plane.geojson.</p><div style="break-before: page; page-break-before: always;"></div><h1 id="compact-position-reporting-cpr-"><a class="header" href="#compact-position-reporting-cpr-">Compact Position Reporting (CPR) :</a></h1>
<p style="text-align:justify;">La contrainte des 56 bits de données dans le cadre de la position peut être problématique pour obtenir une précision suffisante. En effet, le rôle numéro 1 du contrôle aérien est d’assurer la sécurité des avions par une bonne séparation de ceux-ci. Or pour ce faire, il faut avoir l’altitude de l’avion, sa latitude, et sa longitude.</p>
<p style="text-align:justify;">Pour le codage de la latitude/longitude, en pratique une précision suffisante (environs 5 mètres près) est atteinte en 45 bits, or seul 35 sont utilisés. Et cela grâce à l’algorithme de compact position reporting.</p>
<p style="text-align:justify;">Cet algorithme repose sur le découpage du globe en zone longitudinale et latitudinal. On procède à deux découpages légèrement différents, ce qui donne deux grilles que l’on nomme paire et impaire. Ainsi, au lieu d’encoder la position sur un seul message, seule la position à l’intérieur d’une case d’une grille est codée. On transmet alors cette position « interne » à la grille sur un message qui indique sa parité, puis en couplant les messages de positions pair et impair, nous parvenons à identifier la position réelle de l’avion.</p>
<p style="text-align:justify;">Un exemple de l’idée qu’utilise l’algorithme CPR peut se faire à l’aide de surface « simple » de 16x16, on divise cette surface par une grille de 5x5, notre grille paire, et une grille de 4x4, notre grille impaire.</p>
<p style="text-align:justify;">La position que l’on souhaite obtenir est de (x=7 ; y=9). Cette position se trouve aux coordonnées (x = 2 ; y=4) d’une case de la grille paire et dans (x= 3 ; y = 1) de la grille impaire. On retrouve la position en superposant toutes les possibilités des deux grilles, et en obtenant une unique correspondance entre les deux.</p>
<p style="text-align: center;">
<img  typeof="foaf:Image" src="rustracker/../images/cpr.png"  alt="" title="cpr">  
</p>
<p style="text-align:justify;">En pratique, l’algorithme CPR commence par décoder dans cet ordre l’index de la zone latitudinale, la latitude, puis l’index de la zone longitudinale puis la longitude. En effet, on cherche la position d’abord globale, c’est-à-dire identifier la « case » dans laquelle se situe l’avion.</p>
<p style="text-align:justify;">Cette recherche qui s’effectue grâce à un message pair et impair donne une position « globale ».</p>
<p style="text-align:justify;">Ce premier décodage de position permet en effet de connaître la zone dans laquelle l’avion se situe. Puisque le déplacement de l’avion est continu, pour le décodage des positions suivantes, les index longitudinaux et latitudinaux peuvent être directement déduis de la position précédente. On utilisera alors qu’un seul message de parités quelconque.</p>
<p style="text-align:justify;">Les messages de positions transmettent aussi l’altitude qui se décode sans algorithme particulièrement remarquable.</p>
<p style="text-align:justify;">
</p><div style="break-before: page; page-break-before: always;"></div><h1 id="gestion-des-erreurs-de-positions-"><a class="header" href="#gestion-des-erreurs-de-positions-">Gestion des erreurs de positions :</a></h1>
<p style="text-align:justify;">L’algorithme de CPR présente un avantage certain. Toutefois, il peut comporter des erreurs. Celles-ci sont principalement dûes au décodage des index des zones de latitude et longitude, et à d’autres calculs sensibles. Principalement lors de la transition de l’avion entre deux zones distinctes.</p>
<p style="text-align:justify;">Comme présenté par la NASA (cf. bibliographie), ces erreurs sont dûes à l’utilisations de nombres flottants. Leur code fournit des preuves en temps réel de leurs résultats grâce à l’ACSL.</p>
<p style="text-align:justify;">Cependant, nous devons trouver un moyen de traiter ces erreurs lorsqu’elles surviennent. </p>
<p style="text-align:justify;">Plusieurs solutions sont suggérées dans l’ouvrage de Junzi Sun (cf. bibliographie), dont la cohérence de la position de l’avion en fonction de la portée de l’antenne. Cette solution n’est pas envisageable pour nous car les récepteurs communiquent de façon anonyme avec le serveur.</p>
<p style="text-align:justify;">En observant les positions aberrantes que nous obtenions, on a remarqué une oscillation de la trajectoire. Nous avons donc imaginé une autre solution, qui est un test de cohérence. </p>
<p style="text-align: center;">
<img  typeof="foaf:Image" src="rustracker/../images/erreur.png"  alt="" title="erreur">  
</p>
<p style="text-align:justify;">Comme présenté postérieurement, les messages de vitesses donnent une information : le « Track angle », qui est le cap suivi par l’avion (entre 0° et 360°). Or ce cap peut aussi être obtenu par une déduction à partir des deux dernières positions connues qui créent un vecteur dont la direction est égale au cap (bien que plus imprécis).</p>
<p style="text-align:justify;">En comparant les deux résultats obtenus sur les toutes premières positions décodées de l’avion, nous pouvons détecter ces oscillations qui sont impossibles avec un cap constant et donc éliminer ces trajectoires problématiques. </p>
<h1 id="mise-en-pratique-"><a class="header" href="#mise-en-pratique-">Mise en pratique :</a></h1>
<p style="text-align:justify;">Cette comparaison de cap était initialement effectuée sur tous les points de la trajectoire, cependant le calcul est lourd et a entraîné un retard du serveur sur les messages reçus. Nous avons donc fait le choix de tester seulement les premières positions de l'avion.</p><div style="break-before: page; page-break-before: always;"></div><h1 id="vitesse"><a class="header" href="#vitesse">Vitesse</a></h1>
<p>Les messages portant les informations de vitesses ont un type-code égal à 19.</p>
<p>Les messages de vitesse sont contitués de la manière suivante : </p>
<table><thead><tr><th></th><th>MSG</th><th>BITS</th></tr></thead><tbody>
<tr><td><strong>Type Code</strong></td><td>1-5</td><td>5</td></tr>
<tr><td><strong>Sub-Type</strong></td><td>6-8</td><td>3</td></tr>
<tr><td><strong>Intent change flag</strong></td><td>9</td><td>1</td></tr>
<tr><td><strong>IFR capability flag</strong></td><td>10</td><td>1</td></tr>
<tr><td><strong>Navigation uncertainty category for velocity</strong></td><td>11-13</td><td>3</td></tr>
<tr><td><strong>Sub-Type specific fields</strong></td><td>14-35</td><td>22</td></tr>
<tr><td><strong>Source bit for vertical rate</strong></td><td>36</td><td>1</td></tr>
<tr><td><strong>Sign bit for vertical rate</strong></td><td>37</td><td>1</td></tr>
<tr><td><strong>Vertical rate</strong></td><td>38-46</td><td>9</td></tr>
<tr><td><strong>Reserved</strong></td><td>47-48</td><td>2</td></tr>
<tr><td><strong>Sign bit for GNSS and Baro altitudes difference</strong></td><td>49</td><td>1</td></tr>
<tr><td><strong>Difference between GNSS and Baro altitudes</strong></td><td>50-56</td><td>7</td></tr>
</tbody></table>
<p>Dans le cadre de notre travail, tous ces champs ne sont pas utiles. On s'interresse particulièrement aux champs concernant la vitesse, la vitesse verticale ainsi que l'angle de piste des avions.</p>
<p>Les différents sous-types (Sub-type) permettent de distinguer les types de vitesses enregistrés ainsi que les types des avions (subsonniques et supersonniques).</p>
<table><thead><tr><th><strong>Sub-Type</strong></th><th>Type vitesse</th><th>Type avion</th></tr></thead><tbody>
<tr><td><strong>1</strong></td><td>GS</td><td>Subsonnic</td></tr>
<tr><td><strong>2</strong></td><td>GS</td><td>Supersonnic</td></tr>
<tr><td><strong>3</strong></td><td>TAS or IAS</td><td>Subsonnic</td></tr>
<tr><td><strong>4</strong></td><td>TAS or IAS</td><td>Supersonnic</td></tr>
</tbody></table>
<p>On distingue plusieurs types de vitesses : </p>
<p style="text-align:justify;">
<ul>
  <li> <p style="text-align:justify;"> <b>Indicated Air Speed (IAS) </b> = vitesse indiquée, c'est la vitesse directement lue dans le cockpit de l'avion, elle est mesurée grâce à des capteurs de pression et varie donc en fonction de l'altitude (baisse lorsque l'altitude augmente); </p></li>
  <li> <p style="text-align:justify;"> <b>True Air Speed (TAS) </b>= c'est la vitesse réelle de l'avion relativement à l'air qui l'entoure;</p> </li>
  <li><p style="text-align:justify;"> <b>Ground Speed (GS) </b> = vitesse au sol, il s'agit de la vitesse réelle corrigée qui tient compte des vents.</p>
</li>
</ul> 
</p>
<p style="text-align:justify;">
<p>Puisque qu'il n'y a actuellement plus d'avions supersonniques en circulation (retrait du concorde en 2003), les sous-types 2 et 4 n'ont pour l'instant pas d'utilité. </p></p>
<h2 id="décodage-vitesse"><a class="header" href="#décodage-vitesse">Décodage vitesse</a></h2>
<h3 id="sous-type-1"><a class="header" href="#sous-type-1">Sous-type 1</a></h3>
<p>La partie du message de vitesse utile pour le décodage de la vitesse sont les bits 14 à 35 décomposés de la manière suivante : </p>
<table><thead><tr><th></th><th></th><th><strong>MSG</strong></th><th><strong>BITS</strong></th></tr></thead><tbody>
<tr><td><strong>Direction pour la composante de vitesse E-O</strong></td><td>Dew</td><td>14</td><td>1</td></tr>
<tr><td><strong>Composante de vitesse Est-Ouest</strong></td><td>Vew</td><td>15-24</td><td>10</td></tr>
<tr><td><strong>Direction pour la composante de vitesse N-S</strong></td><td>Dns</td><td>25</td><td>1</td></tr>
<tr><td><strong>Composante de vitesse Nord-Sud</strong></td><td>Vns</td><td>26-35</td><td>10</td></tr>
</tbody></table>
<p style="text-align:justify;">
<p>On calcule la vitesse à partir des composantes Vew et Vns ainsi que des directions Dew et Dns.</p>
<p>On calcule également le track angle (angle de piste) qui permet d'orienter les avions sur la carte à l'aide de ces valeurs.</p>
</p>
<h3 id="sous-type-3"><a class="header" href="#sous-type-3">Sous-type 3</a></h3>
<p style="text-align:justify;">
<p>Les messages de sous-type 3 sont émis lorsque la vitesse au sol de l'avion n'est pas connue (par exemple quand le positionnement par satellite n'est pas disponible). Dans ce cas, la vitesse et le track angle sont directement encodés dans le message de la manière suivante : </p>
</p>
<table><thead><tr><th></th><th></th><th><strong>MSG</strong></th><th><strong>BITS</strong></th></tr></thead><tbody>
<tr><td><strong>Bit de status pour le cap magnétique</strong></td><td>SH</td><td>14</td><td>1</td></tr>
<tr><td><strong>Cap magnétique</strong></td><td>HDG</td><td>15-24</td><td>10</td></tr>
<tr><td><strong>Type de vitesse (IA or TAS)</strong></td><td>T</td><td>25</td><td>1</td></tr>
<tr><td><strong>Vitesse</strong></td><td>AS</td><td>26-35</td><td>10</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="callsign"><a class="header" href="#callsign">Callsign</a></h1>
<p style="text-align:justify;">Le callsign permet d'identifier un avion en vol. À la différence de l'icao, le callsign n'est pas unique, plusieurs avions effectuant le même trajet à des moments différents auront le même callsign. La donnée du callsign est contenue dans les messages dont le type-code est compris entre 1 et 4. Un tel message est structuré de la manière suivante : </p>
<table><thead><tr><th><strong>Data</strong></th><th><strong>TC</strong></th><th><strong>CA</strong></th><th><strong>C1</strong></th><th><strong>C2</strong></th><th><strong>C3</strong></th><th><strong>C4</strong></th><th><strong>C5</strong></th><th><strong>C6</strong></th><th><strong>C7</strong></th><th><strong>C8</strong></th></tr></thead><tbody>
<tr><td><strong>BITS</strong></td><td>5</td><td>3</td><td>6</td><td>6</td><td>6</td><td>6</td><td>6</td><td>6</td><td>6</td><td>6</td></tr>
</tbody></table>
<p>On retrouve le type code (TC) contenu dans les 5 premiers bits suivi de la catégorie de l'engin (CA). Ensuite, chaque bloc de 6 bits permet de déterminer un caractère du callsign.</p>
<p>Pour trouver le callsign il suffit de convertir chaque bloc de 6 bits en décimal, les 8 nombres obtenus sont alors les indices des caractères du callsign dans l'alphabet suivant : </p>
<blockquote>
<p>#ABCDEFGHIJKLMNOPQRSTUVWXYZ#####################0123456789######</p>
</blockquote>
<p>Par exemple, le callsign associé au message suivant est <strong>KLM1023</strong> : </p>
<table><thead><tr><th><strong>MSG</strong></th><th><strong>00100</strong></th><th><strong>000</strong></th><th><strong>001011</strong></th><th><strong>001100</strong></th><th><strong>001101</strong></th><th><strong>110001</strong></th><th><strong>110000</strong></th><th><strong>110010</strong></th><th><strong>110011</strong></th><th><strong>100000</strong></th></tr></thead><tbody>
<tr><td><strong>DATA</strong></td><td>TC</td><td>CA</td><td>11</td><td>12</td><td>13</td><td>49</td><td>48</td><td>50</td><td>51</td><td>32</td></tr>
<tr><td><strong>DATA</strong></td><td>4</td><td>0</td><td>K</td><td>L</td><td>M</td><td>1</td><td>0</td><td>2</td><td>3</td><td>-</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trackui"><a class="header" href="#trackui">Trackui</a></h1>
<p style="text-align:justify;">L’interface graphique est codée en JavaScript. On utilise Leaflet qui est un package permettant de générer une carte. Cette carte affiche en temps réel les avions dont la position est partagée.</p>
<p style="text-align:justify;">Cependant comme ce n’est pas toujours le cas (selon le type de transpondeur de l’avion), et afin de présenter les informations supplémentaires tel que le numéro de vol, l’altitude et la vitesse, on a fait le choix d’ajouter un tableau contenant la liste des avions.</p>
<p style="text-align:justify;">De plus, ce tableau dispose de code OACI « cliquable » pour les avions dont la position est visible sur la carte. Lorsque l’on clique sur un bouton, la carte se recentre alors sur l’avion sélectionné et affiche son icone et sa trajectoire dans une couleur différente afin de le mettre en valeur.</p>
<p style="text-align:justify;">Enfin, la collecte des informations se fait en récupérant les informations du geojson généré par Rustracker toutes les 1,5 secondes. Le geojson est une FeatureCollection qui regroupe plusieurs Features qui sont nos avions. Ces Features ont pour ID le code OACI, et sont des LineString, c’est-à-dire que le champ geometry contient l’ensemble des points qui composent la trajectoire, puis dispose en attribut du reste des informations de l’avion.</p>
<p style="text-align:justify;">En itérant sur toutes les Feature, on ajoute pour chacune un calque à la carte qui affiche la trajectoire, et l’icone que l’on oriente grâce au « track angle » (la route suivie par l’avion). Chacun de ces calques sont dans un même groupe de calque.</p>
<p style="text-align:justify;">
À chaque nouvelle réception des données du geojson, on vide alors ce groupe de calque afin de le remplir de nouveau avec les informations actualisées.</p><div style="break-before: page; page-break-before: always;"></div><h1 id="storyline"><a class="header" href="#storyline">Storyline</a></h1>
<p>Le rétro planning original était:</p>
<p><img src="images/retroplan.png" alt="Retro Planning" /></p>
<p>Mais des difficultés son apparu pendant le projet, ce qui nous a forcé à le modifier légèrement.</p>
<hr />
<h3 id="réunion-du-270122"><a class="header" href="#réunion-du-270122">Réunion du 27/01/22</a></h3>
<p>Création du repertoire Git (licence GNU GPL v3).
Discussion sur nos objectifs concernant le projet, livrable minimal, livrable amélioré.
Langage : RUST (formation en cours) plus compliqué à prendre en main que Java/Python mais plus optimisé pour notre projet.</p>
<p><strong>Discussion sur la structure :</strong></p>
<p>--&gt; Classe radar :</p>
<ul>
<li>Qui hérite de thread</li>
<li>S'éxécute à l'infini</li>
<li>Reçoit des essages en permanence et créée un objet avion dès qu'il est détecté</li>
<li>Extrait le message en cherchant le préambule classique de l'ADS-B</li>
</ul>
<p>--&gt; Classe Avion :</p>
<ul>
<li>Message en binaire</li>
<li>Data : 56 bits, soit la vitesse, soit le numéro de vol, soit les coordonnées </li>
<li>Traduit les données </li>
<li>Crée une carte toutes les X secondes</li>
</ul>
<hr />
<h3 id="réunion-du-100222"><a class="header" href="#réunion-du-100222">Réunion du 10/02/22</a></h3>
<p>Discussion autour du projet, notamment autour de la structure du projet ainsi que des grandes étapes, et autour du rétroplanning que nous allons présenter dans le premier livrable. </p>
<p>Début du code de fonctions simples pour prendre en main RUST : </p>
<ul>
<li>Une fonction qui découpe un message binaire de 56 bits afin de récupérer les sections de bits correspondant aux informations sur le vol</li>
<li>Une fonction qui gère la base de données contenant les informations relatives aux avions (modèle, moteur, etc)</li>
</ul>
<hr />
<h3 id="réunion-du-170222"><a class="header" href="#réunion-du-170222">Réunion du 17/02/22</a></h3>
<p>Discussion sur le livrable 1 à rendre dans la semaine.
Écriture de la présentation du projet avec les objectifs (livrable minimal et idéal), diagramme de séquence et rétroplanning.<br />
La fonction callsign() qui découpe et traduit le message de 56 bits.
Le groupe continue son apprentissage du RUST.</p>
<hr />
<h3 id="réunion-du-240222"><a class="header" href="#réunion-du-240222">Réunion du 24/02/22</a></h3>
<ul>
<li>Le premier livrable a été téléversé (18/02) sur moodle.</li>
<li>Code des fonctions permettant d'extraire la position (latitude, longitude) du message.</li>
<li>Discussion pour l'interface graphique : nous allons commencer à regarder imgui.</li>
</ul>
<hr />
<h3 id="réunion-du-030322-point-rencontre"><a class="header" href="#réunion-du-030322-point-rencontre">Réunion du 03/03/22 (point rencontre)</a></h3>
<ul>
<li>Préférable de scinder le projet en deux sous-projets : 'backend' et 'frontend'. Création du second répertoire <a href="https://github.com/GuilhemHnr/trackui">trackui</a> dans ce but précis.</li>
<li>Discussion autout de l'interface graphique : on part sur imgui avec l'utilisation de ZeroMQ pour séparer le 'backend' et le 'frontend'.</li>
<li>Réception des messages : voir le framword rtlsdr_mt (pas actualisé) sinon se tourner vers soapysdr.</li>
<li>Choix d'utiliser des array de booléens pour représenter les messages binaires plutôt que des string pour gain de mémoire.</li>
<li>Discussion autour du livrable 2 à rendre la semaine d'après.</li>
</ul>
<hr />
<h3 id="réunion-du-160322-point-rencontre"><a class="header" href="#réunion-du-160322-point-rencontre">Réunion du 16/03/22 (point rencontre)</a></h3>
<ul>
<li>Discussion autour des bases de données : se tourner vers SQLLite3 plutôt.</li>
<li>Clarifier le code aux endroits où il devient un peu lourd et peu intuitif.</li>
<li>Regarder des librairies de logging pour éventuellement générer des logs.</li>
<li>Problèmes réglé pour imgui.</li>
<li>Discussion autour de l'interface graphique, il faut choisir entre :
<ul>
<li>imgui qui fonctionnerait avec ZeroMQ : il faut chercher comment générer une carte (openstreetmap), les tiles</li>
<li>interface web avec HTML/CSS, Javascript : utilisation de leaflet pour générer facilement une carte, utiliser des websockets pour communiquer entre back/front</li>
</ul>
</li>
</ul>
<hr />
<h3 id="réunion-du-29032022-rapide-"><a class="header" href="#réunion-du-29032022-rapide-">Réunion du 29/03/2022 (rapide) :</a></h3>
<ul>
<li>Choix d'utiliser Yew et leaflet-rs pour l'interface graphique</li>
<li>Prise en main de Yew et leaflet-rs, mais beaucoup de difficultés sont rencontrées avec l'utilisation de cette bibliothèque.</li>
<li>ZeroMQ : grâce à l'exemple fournit par  Rémy Grünblatt un code minimal d'emission/reception serveur/client a été mis au point et fonctionne correctement (pour l'instant en local).</li>
</ul>
<h4 id="objectifs-pour-la-semaine-prochaine-"><a class="header" href="#objectifs-pour-la-semaine-prochaine-">Objectifs pour la semaine prochaine :</a></h4>
<ul>
<li>Réussir à afficher une icone d'avion et à gérer sa position sur la carte</li>
<li>Gérer proprement la réception des messages côté client</li>
<li>Gérer l'affichage des données côté client</li>
</ul>
<hr />
<h3 id="réunion-du-14042022-point-rencontre-"><a class="header" href="#réunion-du-14042022-point-rencontre-">Réunion du 14/04/2022 (point rencontre) :</a></h3>
<ul>
<li>Discussion autour de l'interface graphique, notamment de Yew qui nous pose plusieurs problèmes : on laisse tomber le rust pour le web et on part sur du web pur / javascript.</li>
<li>Discussion autour de l'organisation du projet : il faut que chacun s'organise pour participer au projet (frontend, backend, connexion à internet, rapport, slides soutenance etc...).</li>
<li>Discussion autour de la forme du rapport : possibilité d'utiliser des fichiers markdown puis de les convertir avec pandoc.</li>
<li>La redistribution des rôles :<br />
--&gt; Guilhem : termine le backend côté web<br />
--&gt; Romain : s'occupe du côté serveur, mise en place d'une vm pour pouvoir faire passer les sockets par internet et utiliser plusieurs antennes<br />
--&gt; Artur : s'occupe du frontend, apparence de l'interface web<br />
--&gt; Bastian : rédige le rapport sous la forme de rustbook</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h1>
<p>Les grands objectifs du projet sont remplis et notre livrable final est opérationnel. Ce projet aura été très enrichissant dans la mesure où nous avons découvert le langage de programmation RUST et nous avons eu a traiter diverses problématiques (traitement du signal, interface web, serveur sur machine virtuelle, programmation asynchrone, communications tcp, etc).</p>
<h3 id="contributeurs"><a class="header" href="#contributeurs">Contributeurs</a></h3>
<p>Les quatre étudiants de Télécom SudParis ayant contribués au projet sont : </p>
<ul>
<li><a href="https://github.com/Witaek">Romain Amédée</a></li>
<li><a href="https://github.com/ArthurChauve">Arthur Chauve</a></li>
<li><a href="https://github.com/GuilhemHnr">Guilhem Honoré</a></li>
<li><a href="https://github.com/blaaass">Bastian Larvor</a></li>
</ul>
<p>Un grand merci à <a href="https://github.com/rgrunbla">Rémy Grünblatt</a> pour ses conseils et son aide.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bibliographie"><a class="header" href="#bibliographie">Bibliographie</a></h1>
<h1 id="the-1090mhz-riddle"><a class="header" href="#the-1090mhz-riddle">The 1090Mhz Riddle</a></h1>
<code>
@book{sun1090mhz,
    author = {Sun, Junzi}, 
    title = {The 1090 Megahertz Riddle: A Guide to Decoding Mode S and ADS-B Signals},
    publisher = {TU Delft OPEN Publishing},
    year = 2021,
    edition = 2,
    isbn = {978-94-6366-402-8},
    doi = {10.34641/mg.11}
}
</code>
<h1 id="explication-de-la-nasa-sur-lalgorithme-cpr"><a class="header" href="#explication-de-la-nasa-sur-lalgorithme-cpr">Explication de la NASA sur l'algorithme CPR</a></h1>
<p><a href="https://github.com/nasa/cpr">GitHub NASA</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
